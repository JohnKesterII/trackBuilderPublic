<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>DropComprehensive's Track Builder | Public Beta 1.0.0</title>
  <style>
    :root{
        --bg:#0b1323; --panel:#0e1b2c; --panel-2:#0b1426; --ink:#e8eef8; --muted:#9fb2cc; --accent:#4ea1ff; --accent2:#71f9a8; --border:#1a2a46;
        --track:#2a3347; --edge:#ffffff;
        --corner-slow:#ff5a5a; --corner-med:#ffb84d; --corner-fast:#74d680; --drs:#4ec9ff;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; background:radial-gradient(1200px 800px at 65% 20%, #0e1a32 0%, var(--bg) 60%); color:var(--ink); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}

    /* Layout */
    #wrap{display:grid; grid-template-columns:400px 1fr; grid-template-rows:56px 1fr; height:100%}
    #wrap.preview-mode{grid-template-columns:1fr; grid-template-rows:1fr}
    header{grid-column:1/3; display:flex; align-items:center; gap:12px; padding:10px 14px; background:linear-gradient(180deg,var(--panel-2),#0a1526); border-bottom:1px solid var(--border); box-shadow:0 8px 24px rgba(0,0,0,.25)}
    header h1{font-size:16px; margin:0; font-weight:800; letter-spacing:.2px}
    .pill{font:600 12px/1 ui-monospace,Menlo,Consolas,monospace; color:#d2e6ff; background:#0f1c32; border:1px solid var(--border); border-radius:6px; padding:4px 6px}
    .sp{flex:1}
    .btn{appearance:none; border:1px solid var(--border); background:#0c1629; color:#e8eef8; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600}
    .btn.primary{background:var(--accent); color:#071225; border-color:#0d3a72}
    .btn.ghost{background:transparent}
    .btn.icon{width:36px; height:36px; padding:8px; display:flex; align-items:center; justify-content:center; font-size:16px}
    .btn.icon:disabled{opacity:0.4; cursor:not-allowed}

    aside{background:linear-gradient(180deg,var(--panel),#0c172b); border-right:1px solid var(--border); padding:12px; overflow:auto}
    .group{border:1px solid var(--border); border-radius:12px; padding:10px; background:rgba(10,22,40,.6); margin-bottom:12px; box-shadow:inset 0 0 0 1px rgba(255,255,255,.02)}
    .group h3{margin:0 0 8px 0; font-size:12px; color:var(--muted); text-transform:uppercase; letter-spacing:.12em}
    .row{display:flex; align-items:center; gap:10px; margin:8px 0}
    .row label{flex:1; color:var(--muted); font-size:13px}
    .row input[type=range]{flex:1}
    /* Modern toggles (replace checkboxes with switches) */
    .row input[type=checkbox]{
      appearance:none; -webkit-appearance:none; width:44px; height:24px; flex:0 0 44px;
      background:#0f1c32; border:1px solid var(--border); border-radius:999px; position:relative; cursor:pointer;
      transition:background .2s ease,border-color .2s ease, box-shadow .2s ease;
      transform:none; outline:none;
    }
    .row input[type=checkbox]::after{
      content:""; position:absolute; top:2px; left:2px; width:18px; height:18px; border-radius:50%;
      background:#cfe3ff; box-shadow:0 2px 8px rgba(0,0,0,.35); transition:left .2s ease, background .2s ease;
    }
    .row input[type=checkbox]:checked{ background:linear-gradient(180deg, var(--accent), #2b8cff); border-color:#1f5fb0; }
    .row input[type=checkbox]:checked::after{ left:22px; background:#071225; }
    .row input[type=checkbox]:focus-visible{ box-shadow:0 0 0 3px rgba(78,161,255,.35); }
    .row input[type=number]{width:96px; background:#0c1629; color:#e8eef8; border:1px solid var(--border); padding:8px 10px; border-radius:8px}
    .value-badge{min-width:60px; text-align:center; padding:4px 6px; border:1px solid var(--border); border-radius:6px; background:#0f1c32; font:600 12px ui-monospace,Menlo,Consolas,monospace; color:#cfe3ff}
    .readonly{opacity:.8; pointer-events:none}

    /* Toggle */
    .mode-toggle{display:flex; gap:6px; background:#0c1629; border:1px solid var(--border); border-radius:8px; padding:4px}
    .mode-toggle button{flex:1; background:transparent; border:none; color:#cfe3ff; font-weight:700; padding:6px 8px; border-radius:6px; cursor:pointer}
    .mode-toggle button.active{background:#123054}

    

    /* Range sliders */
    .row input[type=range], #miniEdit input[type=range]{
      -webkit-appearance:none; appearance:none; height:28px; background:transparent;
    }
    .row input[type=range]::-webkit-slider-runnable-track, #miniEdit input[type=range]::-webkit-slider-runnable-track{
      height:8px; border-radius:999px; background:linear-gradient(90deg,#123054,#1b3a63); border:1px solid var(--border);
    }
    .row input[type=range]::-webkit-slider-thumb, #miniEdit input[type=range]::-webkit-slider-thumb{
      -webkit-appearance:none; width:18px; height:18px; border-radius:50%; background:var(--accent); border:2px solid #071225; margin-top:-6px;
      box-shadow:0 2px 10px rgba(0,0,0,.4);
    }
    .row input[type=range]::-moz-range-track, #miniEdit input[type=range]::-moz-range-track{
      height:8px; border-radius:999px; background:linear-gradient(90deg,#123054,#1b3a63); border:1px solid var(--border);
    }
    .row input[type=range]::-moz-range-thumb, #miniEdit input[type=range]::-moz-range-thumb{
      width:18px; height:18px; border-radius:50%; background:var(--accent); border:2px solid #071225;
      box-shadow:0 2px 10px rgba(0,0,0,.4);
    }

    /* Selects */
    select{ background:#0c1629; color:var(--ink); border:1px solid var(--border); border-radius:8px; padding:8px 28px 8px 10px; outline:none;
      background-image: linear-gradient(45deg, transparent 50%, #9fb2cc 50%), linear-gradient(135deg, #9fb2cc 50%, transparent 50%);
      background-position: calc(100% - 16px) 50%, calc(100% - 12px) 50%; background-size:4px 4px, 4px 4px; background-repeat:no-repeat; }
    select:focus-visible{ box-shadow:0 0 0 3px rgba(78,161,255,.35); }

    /* Group polish */
    .group{ background:linear-gradient(180deg, rgba(10,22,40,.65), rgba(10,22,40,.45)); border-radius:14px; border:1px solid var(--border);
      box-shadow: 0 6px 18px rgba(0,0,0,.25), inset 0 0 0 1px rgba(255,255,255,.02); }
    .group h3{ letter-spacing:.14em; color:#a9bdd8; }

    /* Buttons polish */
    .btn{ border-radius:10px; padding:9px 12px; border:1px solid var(--border); transition: transform .08s ease, box-shadow .2s ease, background .2s ease; }
    .btn:hover{ transform: translateY(-1px); box-shadow:0 6px 16px rgba(0,0,0,.25); }
    .btn:active{ transform: translateY(0); box-shadow:none; }
    .btn.primary{ background:linear-gradient(180deg,var(--accent),#2b8cff); border-color:#1f5fb0; color:#071225; }

    /* Header polish */
    header{ background:linear-gradient(180deg, var(--panel-2) 0%, #0a1526 40%, #091226 100%); }
    .pill{ border-radius:8px; }

    /* Labels */
    .row label{ color:#b1c4dd; }

    /* Focus ring */
    input:focus-visible, button:focus-visible{ outline:none; box-shadow:0 0 0 3px rgba(78,161,255,.35); }

    /* Canvas area */
    #stage{position:relative}
    #canvas{width:100%; height:100%; display:block; background:radial-gradient(900px 700px at 50% 50%, #0d1a31 0%, #0b1323 60%); cursor:crosshair; border-left:1px solid var(--border)}
    .preview-mode #canvas{border-left:none; cursor:grab}
    .preview-mode.preview-edit #canvas{cursor:crosshair}
    #hud{position:absolute; left:10px; bottom:10px; background:rgba(10,20,36,.75); border:1px solid var(--border); border-radius:10px; padding:6px 8px; font-size:12px; backdrop-filter:blur(4px)}
    /* Mini point editor popup (only selected point) */
    #miniEdit{position:absolute; top:12px; left:12px; z-index:6; width:280px; background:rgba(10,22,40,.95); border:1px solid var(--border); border-radius:12px; box-shadow:0 8px 24px rgba(0,0,0,.35); padding:10px; backdrop-filter:blur(6px)}
    #miniEdit .row{display:flex; align-items:center; gap:8px; margin:8px 0}
    #miniEdit h4{margin:0 0 6px 0; font-size:12px; color:var(--muted); text-transform:uppercase; letter-spacing:.12em}
    #miniEdit label{flex:1; color:var(--muted); font-size:12px}
    #miniEdit input[type=number]{width:84px; background:#0c1629; color:#e8eef8; border:1px solid var(--border); padding:6px; border-radius:6px}
    #miniEdit input[type=range]{flex:1}
    #miniEdit .value-badge{min-width:54px}
    #miniEdit.hidden{display:none}

    .help{font-size:12px; color:var(--muted)}
    .kbd{font:600 12px ui-monospace,Menlo,Consolas,monospace; background:#0f1c32; border:1px solid var(--border); border-radius:6px; padding:1px 6px; color:#d2e6ff}

    /* Preview mode */
    .hidden{display:none !important}
    #previewOverlay{position:absolute; inset:0; pointer-events:none}
    #exitPreview{position:absolute; top:12px; right:12px; z-index:5; pointer-events:auto}

    /* Pitlane */
    :root{ --pit:#6b7280; --pit-edge:#cbd5e1; }
    /* Alternate layouts */
    :root{ --alt-layout:#89a6ff; --alt-layout-ctrl: rgba(137,166,255,0.35); }

    /* Hidden file input */
    #fileInput{display:none}

    /* Floating Info Button */
    #infoBtn{position:fixed; right:16px; bottom:16px; z-index:50; width:40px; height:40px; border-radius:50%; border:1px solid var(--border); background:#0c1629; color:#cfe3ff; display:flex; align-items:center; justify-content:center; font-weight:800; cursor:pointer; box-shadow:0 6px 16px rgba(0,0,0,.35)}
    #infoBtn:hover{background:#123054}

    /* Help Overlay */
    #helpOverlay{position:fixed; inset:0; background:rgba(4,10,20,0.7); backdrop-filter:saturate(1.1) blur(2px); z-index:60; display:none; align-items:center; justify-content:center; padding:24px}
    #helpCard{width:min(900px, 92vw); max-height:84vh; overflow:auto; background:linear-gradient(180deg,var(--panel),#0c172b); border:1px solid var(--border); border-radius:14px; box-shadow:0 16px 48px rgba(0,0,0,.5); color:var(--ink)}
    #helpCard header{display:flex; align-items:center; justify-content:space-between; padding:14px 16px; border-bottom:1px solid var(--border)}
    #helpCard header h2{margin:0; font-size:16px}
    #helpClose{appearance:none; border:1px solid var(--border); background:#0c1629; color:#cfe3ff; width:32px; height:32px; border-radius:8px; cursor:pointer; font-weight:800}
    #helpClose:hover{background:#123054}
    #helpBody{padding:16px}
    #helpBody h3{margin:12px 0 6px; font-size:13px; color:var(--muted); text-transform:uppercase; letter-spacing:.12em}
    #helpBody ul{margin:8px 0 16px; padding-left:18px}
    #helpBody li{margin:6px 0; line-height:1.4}
  </style>
  </head>
<body>
  <div id="wrap">
    <header id="topbar">
      <h1>Track Builder</h1>
      <button id="undoBtn" class="btn icon ghost" title="Undo (Ctrl+Z)" disabled>‚Ü∂</button>
      <button id="redoBtn" class="btn icon ghost" title="Redo (Ctrl+Y)" disabled>‚Ü∑</button>
      <button id="importBtn" class="btn icon ghost" title="Import Track">üìÅ</button>
      <button id="exportBtn" class="btn icon ghost" title="Export Track">üíæ</button>
      <input type="file" id="fileInput" accept=".json" />
      <div class="pill" id="hintPill">DropComprehensive's Track Builder Public Beta 1.0.0</div>
      <div class="sp"></div>
      <button id="previewBtn" class="btn ghost">Preview</button>
      <button id="pitEditBtn" class="btn ghost" title="Edit Pitlane">Pit Edit</button>
      <button id="analyzeBtn" class="btn ghost" title="Detect corners/straights">Analyze</button>
      <button id="clear" class="btn">Clear</button>
      <button id="fit" class="btn primary">Fit</button>
    </header>

    <aside id="sidebar">
      <!-- Mode group removed for vector-only build -->

      <div class="group" id="layoutsGroup">
        <h3>Layouts</h3>
        <div class="row">
          <label for="layoutSelect">Active layout</label>
          <select id="layoutSelect" style="flex:1"></select>
        </div>
        <div class="row">
          <label for="showAltOverlays">Show other layouts</label>
          <input id="showAltOverlays" type="checkbox" checked>
        </div>
        <div class="row" style="gap:8px">
          <button id="layoutNew" class="btn">New</button>
          <button id="layoutClone" class="btn">Clone</button>
          <button id="layoutRename" class="btn">Rename</button>
          <button id="layoutDelete" class="btn" style="border-color:#5a1a1a;background:#281316">Delete</button>
        </div>
        <div class="help">Use layouts for alternate routes (e.g., with/without chicane). Clone the main layout, then edit the variant.</div>
      </div>

      <div class="group" style="display:none">
        <h3>Resolution</h3>
        <div class="row">
          <label for="resolution">Sampling resolution (smoothness)</label>
          <input id="resolution" type="range" min="16" max="1200" step="1" value="300">
          <div id="valResolution" class="value-badge">300</div>
        </div>
        <div class="row">
          <label for="closed">Closed loop</label>
          <input id="closed" type="checkbox">
        </div>
      </div>

      <div class="group">
        <h3>Track Width</h3>
        <div class="row">
          <label for="usePerWidth">Use per-point widths</label>
          <input id="usePerWidth" type="checkbox">
        </div>
        <div class="row">
          <label for="globalWidth">Global width</label>
          <input id="globalWidth" type="range" min="2" max="40" step="0.5" value="12">
          <div id="valGlobalWidth" class="value-badge">12.0</div>
        </div>
      </div>

      <div class="group">
        <h3>Pitlane</h3>
        <div class="row">
          <label for="pitEnabled">Enable pitlane</label>
          <input id="pitEnabled" type="checkbox">
        </div>
        <div class="row">
          <label for="pitWidth">Pit width (m)</label>
          <input id="pitWidth" type="range" min="3" max="20" step="0.5" value="8">
          <div id="valPitWidth" class="value-badge">8.0</div>
        </div>
        <div class="help">Click Pit Edit (top bar) to add/move pit points. Pitlane is open and drawn with solid edges.</div>
      </div>

      <div class="group" id="sfGroup">
        <h3>Start/Finish Marker</h3>
        <div class="row" style="gap:8px">
          <button id="sfSet" class="btn">Set from selected</button>
          <button id="sfPlace" class="btn">Place on track</button>
          <button id="sfClear" class="btn">Clear</button>
        </div>
        <div class="row">
          <label for="sfPreview">Show in preview</label>
          <input id="sfPreview" type="checkbox">
        </div>
        <div class="help">Select a vector node, then click Set from selected to mark the start/finish line there.</div>
      </div>

      <div class="group" style="display:none">
        <h3>Banking / Tilting</h3>
        <div class="row">
          <label for="usePerBank">Use per-point bank</label>
          <input id="usePerBank" type="checkbox">
        </div>
        <div class="row">
          <label for="globalBank">Global bank (¬∞)</label>
          <input id="globalBank" type="range" min="-20" max="20" step="0.5" value="0">
          <div id="valGlobalBank" class="value-badge">0.0¬∞</div>
        </div>
        <div class="row">
          <label for="autoBank">Auto bank by curvature</label>
          <input id="autoBank" type="checkbox">
        </div>
        <div class="row">
          <label for="autoStrength">Auto strength (deg per rad/unit)</label>
          <input id="autoStrength" type="range" min="0" max="40" step="1" value="12">
          <div id="valAutoStrength" class="value-badge">12</div>
        </div>
        <div class="row">
          <label for="autoMax">Auto max (¬∞)</label>
          <input id="autoMax" type="range" min="0" max="30" step="1" value="12">
          <div id="valAutoMax" class="value-badge">12¬∞</div>
        </div>
        <div class="row">
          <label for="smoothBank">Smooth bank (¬±2 samples)</label>
          <input id="smoothBank" type="checkbox" checked>
        </div>
        <div class="row">
          <label for="showBankViz">Show bank viz</label>
          <input id="showBankViz" type="checkbox" checked>
        </div>
      </div>

      <div class="group">
        <h3>Selected Node</h3>
        <div class="row">
          <label>Index</label>
          <div id="selIndex" class="value-badge">‚Äî</div>
        </div>
        <div class="row">
          <label for="px">X</label>
          <input id="px" type="number" step="1" value="0">
        </div>
        <div class="row">
          <label for="py">Y</label>
          <input id="py" type="number" step="1" value="0">
        </div>
        <!-- Vector-selected controls -->
        <div class="row vector-only">
          <label for="vradius">Corner radius</label>
          <input id="vradius" type="number" step="0.5" value="0">
        </div>
        <div class="row vector-only">
          <label for="vtype">Corner type</label>
          <select id="vtype">
            <option value="sharp">Sharp</option>
            <option value="round">Round</option>
          </select>
        </div>
        <div class="row" style="gap:8px">
          <button id="applyXY" class="btn">Apply X/Y</button>
          <button id="deletePoint" class="btn" style="border-color:#5a1a1a;background:#281316">Delete</button>
        </div>
        <div class="row" style="gap:8px">
          <button id="insertMid" class="btn" title="Insert midpoint between selected and next">Insert Midpoint</button>
        </div>
      </div>

      <div class="group">
        <h3>Snap to Grid</h3>
        <div class="row">
          <label for="snap">Snap to grid</label>
          <input id="snap" type="checkbox">
          <input id="grid" type="number" value="24" min="4" max="200">
        </div>
        <div class="row" style="display:none">
          <label for="showCtrl">Show control polyline</label>
          <input id="showCtrl" type="checkbox" checked>
        </div>
        <div class="row" style="display:none">
          <label for="fitOnPreview">Fit on preview</label>
          <input id="fitOnPreview" type="checkbox" checked>
        </div>
      </div>

      <div class="group" id="vectorGroup" style="display:none">
        <h3>Vector</h3>
        <div class="row">
          <label for="vectorFromTrack">Build outline from current centerline</label>
          <input id="vectorFromTrack" type="checkbox">
        </div>
        <div class="row">
          <label for="vectorInflate">Outline offset</label>
          <input id="vectorInflate" type="range" min="0" max="80" step="0.5" value="6">
          <div id="valVectorInflate" class="value-badge">6.0</div>
        </div>
        <div class="row">
          <label for="showCornerHandles">Show corner handles</label>
          <input id="showCornerHandles" type="checkbox" checked>
        </div>
        <div class="row" style="gap:8px">
          <button id="vectorBuildNow" class="btn">Build Outline Now</button>
        </div>
      </div>

      <div class="group" style="display:none">
        <h3>AI Track Generator</h3>
        <div class="row">
          <label for="genStyle">Style</label>
          <select id="genStyle">
            <option value="balanced" selected>Balanced</option>
            <option value="flow">Flow</option>
            <option value="technical">Technical</option>
            <option value="speed">High Speed</option>
          </select>
        </div>
        <div class="row" style="gap:8px">
          <button id="generateBtn" class="btn primary">Generate Track</button>
          <button id="regenBtn" class="btn">Re‚Äëroll</button>
        </div>
        <div class="help">Uses Length (km) and Discipline above for high‚Äëlevel guidance.</div>
      </div>

      <div class="group" style="display:none">
        <h3>AI Suggestions</h3>
        <div class="row">
          <label for="discipline">Discipline</label>
          <select id="discipline">
            <option value="F1" selected>F1</option>
            <option value="Hypercar">Hypercar (WEC)</option>
            <option value="GT3">GT3</option>
            <option value="Rally">Rally</option>
          </select>
        </div>
        <div class="row">
          <label for="lapKm">Length (km)</label>
          <input id="lapKm" type="number" min="2.5" max="50" step="0.1" value="5.3">
        </div>
        <div class="row" style="gap:8px">
          <button id="suggestBtn" class="btn">Suggest</button>
        </div>
        <div id="suggestBox" class="help" style="white-space:pre-wrap; line-height:1.4"></div>
      </div>

      <div class="group">
        <h3>Shortcuts & Tests</h3>
        <div class="help">
          <div><span class="kbd">M</span> Edit/Add ‚Ä¢ <span class="kbd">P</span> preview ‚Ä¢ <span class="kbd">Esc</span> exit</div>
          <div><span class="kbd">Right‚Äëclick</span> (Edit) select/drag ‚Ä¢ (Add) add ‚Ä¢ Shift+Right inserts</div>
          <div><span class="kbd">Wheel</span> zoom ‚Ä¢ <span class="kbd">Space+drag</span> pan</div>
          <div><span class="kbd">Ctrl+Z</span> undo ‚Ä¢ <span class="kbd">Ctrl+Y</span> redo</div>
        </div>
        <div class="row" style="gap:8px; display:none">
          <button id="testHairpin" class="btn">Load Hairpin Test</button>
          <button id="testChicane" class="btn">Load Chicane Test</button>
        </div>
      </div>
    </aside>

    <div id="stage">
      <canvas id="canvas"></canvas>
      <button id="exitPreview" class="btn primary hidden">Exit Preview (Esc)</button>
      <div id="miniEdit" class="hidden">
        <h4>Selected Point</h4>
        <div class="row">
          <label>Index</label>
          <div id="miniSelIndex" class="value-badge">‚Äî</div>
        </div>
        <div class="row">
          <label for="miniPX">X</label>
          <input id="miniPX" type="number" step="1" value="0">
          <label for="miniPY">Y</label>
          <input id="miniPY" type="number" step="1" value="0">
        </div>
        <div class="row">
          <label for="miniPTension">Tension</label>
          <input id="miniPTension" type="range" min="-2" max="1" step="0.02" value="0.00">
          <div id="miniValPTension" class="value-badge">0.00</div>
        </div>
        <div class="row">
          <label for="miniTBias">Tension Dir</label>
          <input id="miniTBias" type="range" min="-1" max="1" step="0.05" value="0">
          <div id="miniValTBias" class="value-badge">0.00</div>
        </div>
        <div class="row">
          <label for="miniPWidth">Width</label>
          <input id="miniPWidth" type="range" min="2" max="40" step="0.5" value="12">
          <div id="miniValPWidth" class="value-badge">12.0</div>
        </div>
        <div class="row">
          <label for="miniPBank">Bank (¬∞)</label>
          <input id="miniPBank" type="range" min="-20" max="20" step="0.5" value="0">
          <div id="miniValPBank" class="value-badge">0.0¬∞</div>
        </div>
        <div class="row">
          <label for="miniIsCorner">Corner</label>
          <input id="miniIsCorner" type="checkbox">
        </div>
        <div class="row" style="gap:8px">
          <button id="miniApplyXY" class="btn">Apply X/Y</button>
          <button id="miniDeletePoint" class="btn" style="border-color:#5a1a1a;background:#281316">Delete</button>
        </div>
      </div>
      <div id="previewOverlay"></div>
      <div id="hud"></div>
    </div>
  </div>

  <!-- Floating Info Button -->
  <button id="infoBtn" title="Controls & Shortcuts">i</button>
  <!-- Help Overlay -->
  <div id="helpOverlay" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div id="helpCard">
      <header>
        <h2 id="helpTitle">Controls & Shortcuts</h2>
        <button id="helpClose" aria-label="Close">√ó</button>
      </header>
      <div id="helpBody">
        <h3>Mouse</h3>
        <ul>
          <li><span class="kbd">Right‚Äëclick</span> add/drag points (Edit mode)</li>
          <li><span class="kbd">Shift + Right‚Äëclick</span> insert between nearest segment</li>
          <li><span class="kbd">Wheel</span> zoom ‚Ä¢ <span class="kbd">Space + drag</span> pan</li>
        </ul>
        <h3>Keyboard</h3>
        <ul>
          <li><span class="kbd">M</span> toggle Edit/Add ‚Ä¢ <span class="kbd">P</span> Preview ‚Ä¢ <span class="kbd">Esc</span> exit Preview</li>
          <li>Windows: <span class="kbd">Ctrl + Z</span> undo ‚Ä¢ <span class="kbd">Ctrl + Y</span> redo ‚Ä¢ <span class="kbd">Ctrl + Shift + Z</span> redo (alt)</li>
          <li>Mac: <span class="kbd">Cmd + Z</span> undo ‚Ä¢ <span class="kbd">Cmd + Shift + Z</span> redo</li>
        </ul>
        <h3>Vector Editing</h3>
        <ul>
          <li><span class="kbd">Alt + drag</span> link corner radii</li>
          <li>Use <span class="kbd">Pit Edit</span> to add/move pit points</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const hud = document.getElementById('hud');

    const topbar = document.getElementById('topbar');
    const sidebar = document.getElementById('sidebar');
    const vectorGroupEl = document.getElementById('vectorGroup');
    let vectorGroupOriginalParent = vectorGroupEl ? vectorGroupEl.parentElement : null;
    let vectorGroupOriginalNext = vectorGroupEl ? vectorGroupEl.nextElementSibling : null;
    const wrap = document.getElementById('wrap');
    const previewBtn = document.getElementById('previewBtn');
    const previewEditBtn = null;
    const pitEditBtn = document.getElementById('pitEditBtn');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const exitPreviewBtn = document.getElementById('exitPreview');
    const fileInput = document.getElementById('fileInput');
    const genBtn = document.getElementById('generateBtn');
    const regenBtn = document.getElementById('regenBtn');
    const genStyleSel = document.getElementById('genStyle');
    // Mini editor refs
    const mini = {
      panel: document.getElementById('miniEdit'),
      selIndex: document.getElementById('miniSelIndex'),
      px: document.getElementById('miniPX'), py: document.getElementById('miniPY'),
      ptension: document.getElementById('miniPTension'), valPTension: document.getElementById('miniValPTension'),
      tbias: document.getElementById('miniTBias'), valTBias: document.getElementById('miniValTBias'),
      pwidth: document.getElementById('miniPWidth'), valPWidth: document.getElementById('miniValPWidth'),
      pbank: document.getElementById('miniPBank'), valPBank: document.getElementById('miniValPBank'),
      isCorner: document.getElementById('miniIsCorner'),
      applyXY: document.getElementById('miniApplyXY'), deletePoint: document.getElementById('miniDeletePoint')
    };

    // Mode controls
    const btnModeEdit = null;
    const btnModeAdd = null;
    const btnModeVector = null;
    let mode = 'vector'; // vector-only build
    function setMode(m){
      mode = m;
      // vector-only: no mode buttons
      // Reorder Vector group to top in sidebar when in vector mode
      if(vectorGroupEl){
        if(m==='vector'){
          if(!vectorGroupOriginalParent){
            vectorGroupOriginalParent = vectorGroupEl.parentElement;
            vectorGroupOriginalNext = vectorGroupEl.nextElementSibling;
          }
          // Move to very top of sidebar
          sidebar.insertBefore(vectorGroupEl, sidebar.firstChild);
        } else {
          // Restore to original position
          if(vectorGroupOriginalParent){
            if(vectorGroupOriginalNext && vectorGroupOriginalNext.parentElement===vectorGroupOriginalParent){
              vectorGroupOriginalParent.insertBefore(vectorGroupEl, vectorGroupOriginalNext);
            } else {
              vectorGroupOriginalParent.appendChild(vectorGroupEl);
            }
          }
        }
      }
      updateSelectedControlsVisibility();
      if(m==='vector' && UI.vectorFromTrack && UI.vectorFromTrack.checked){
        buildOutlineFromCenterline();
      }
      draw();
    }
    // vector-only: no mode button handlers

    // UI refs
    const UI = {
      tension: document.getElementById('tension'),
      resolution: document.getElementById('resolution'),
      closed: document.getElementById('closed'),
      snap: document.getElementById('snap'),
      grid: document.getElementById('grid'),
      showCtrl: document.getElementById('showCtrl'),
      fitOnPreview: document.getElementById('fitOnPreview'),
      clear: document.getElementById('clear'),
      fit: document.getElementById('fit'),
      valTension: document.getElementById('valTension'),
      valResolution: document.getElementById('valResolution'),
      selIndex: document.getElementById('selIndex'),
      px: document.getElementById('px'), py: document.getElementById('py'),
      ptension: document.getElementById('ptension'), valPTension: document.getElementById('valPTension'),
      tbias: document.getElementById('tbias'), valTBias: document.getElementById('valTBias'),
      pwidth: document.getElementById('pwidth'), valPWidth: document.getElementById('valPWidth'),
      pbank: document.getElementById('pbank'), valPBank: document.getElementById('valPBank'),
      isCorner: document.getElementById('isCorner'),
      usePerWidth: document.getElementById('usePerWidth'), globalWidth: document.getElementById('globalWidth'), valGlobalWidth: document.getElementById('valGlobalWidth'),
      usePerBank: document.getElementById('usePerBank'), globalBank: document.getElementById('globalBank'), valGlobalBank: document.getElementById('valGlobalBank'),
      autoBank: document.getElementById('autoBank'), autoStrength: document.getElementById('autoStrength'), valAutoStrength: document.getElementById('valAutoStrength'), autoMax: document.getElementById('autoMax'), valAutoMax: document.getElementById('valAutoMax'),
      smoothBank: document.getElementById('smoothBank'), showBankViz: document.getElementById('showBankViz'),
      applyXY: document.getElementById('applyXY'), deletePoint: document.getElementById('deletePoint'),
      insertMid: document.getElementById('insertMid'),
      testHairpin: document.getElementById('testHairpin'), testChicane: document.getElementById('testChicane'),
      undoBtn: document.getElementById('undoBtn'), redoBtn: document.getElementById('redoBtn'),
      importBtn: document.getElementById('importBtn'), exportBtn: document.getElementById('exportBtn'),
      lapKm: document.getElementById('lapKm'),
      discipline: document.getElementById('discipline'),
      suggestBtn: document.getElementById('suggestBtn'),
      suggestBox: document.getElementById('suggestBox'),
      pitEnabled: document.getElementById('pitEnabled'), pitWidth: document.getElementById('pitWidth'), valPitWidth: document.getElementById('valPitWidth'),
      sfPreview: document.getElementById('sfPreview'),
      // Vector UI
      vectorFromTrack: document.getElementById('vectorFromTrack'),
      vectorInflate: document.getElementById('vectorInflate'), valVectorInflate: document.getElementById('valVectorInflate'),
      showCornerHandles: document.getElementById('showCornerHandles'),
      vectorBuildNow: document.getElementById('vectorBuildNow'),
      vradius: document.getElementById('vradius'), vtype: document.getElementById('vtype'),
      // Layouts
      layoutSelect: document.getElementById('layoutSelect'),
      layoutNew: document.getElementById('layoutNew'),
      layoutClone: document.getElementById('layoutClone'),
      layoutRename: document.getElementById('layoutRename'),
      layoutDelete: document.getElementById('layoutDelete'),
      showAltOverlays: document.getElementById('showAltOverlays')
    };

    function updateSelectedControlsVisibility(){
      const pointEls = document.querySelectorAll('.point-only');
      const vectorEls = document.querySelectorAll('.vector-only');
      pointEls.forEach(el=>{ el.style.display = (mode==='vector')? 'none' : ''; });
      vectorEls.forEach(el=>{ el.style.display = (mode==='vector')? '' : 'none'; });
    }

    let previewMode = false;
    let previewEditMode = false; // preview with editable points
    let pitEditMode = false; // edit pitlane points
    let analysisMode = false; // toggled by Analyze button
    let analysisCache = null; // cached analysis results

    // World state ‚Äî each point: x,y,t (tension), tb (tension bias -1..1), w (width), b (bank degrees), c (corner mark)
    // Multi-layout support
    /** @typedef {{id:string,name:string,points:{x:number,y:number,t:number,tb?:number,w:number,b:number,c?:boolean}[], vector?:{nodes:{x:number,y:number,type:'sharp'|'round',r:number}[],closed:boolean,inflate:number}}} Layout */
    /** @type {Layout[]} */
    let layouts = [{ id: 'L1', name: 'Main', points: [], vector: { nodes: [], closed: true, inflate: 6 } }];
    let activeLayoutIndex = 0;
    /** @type {{x:number,y:number,t:number,tb?:number,w:number,b:number,c?:boolean}[]} */
    let points = layouts[activeLayoutIndex].points; // alias for active layout points
    function setActiveLayout(idx){
      activeLayoutIndex = Math.max(0, Math.min(idx, layouts.length-1));
      points = layouts[activeLayoutIndex].points;
      // Sync vector aliases to active layout's vector
      const v = layouts[activeLayoutIndex].vector || (layouts[activeLayoutIndex].vector = { nodes: [], closed: true, inflate: (parseFloat(UI.vectorInflate?.value||'6')||6) });
      vNodes = v.nodes;
      vectorClosed = !!v.closed;
      if(UI.vectorInflate) UI.vectorInflate.value = String(v.inflate ?? 6);
      selected = -1;
      vSelected = -1;
      syncSelectedUI();
      if(mode==='vector') syncSelectedVectorUI();
      recompute();
      draw();
      refreshLayoutUI();
    }
    function newLayout(name='Layout '+(layouts.length+1)){
      const id = 'L'+(Date.now().toString(36)+Math.floor(Math.random()*1e6).toString(36)).slice(-6);
      layouts.push({ id, name, points: [], vector: { nodes: [], closed: true, inflate: (parseFloat(UI.vectorInflate?.value||'6')||6) } });
      setActiveLayout(layouts.length-1);
    }
    function cloneActiveLayout(){
      const cur = layouts[activeLayoutIndex];
      const clone = JSON.parse(JSON.stringify(cur.points));
      const id = 'L'+(Date.now().toString(36)+Math.floor(Math.random()*1e6).toString(36)).slice(-6);
      const name = cur.name + ' Copy';
      const vsrc = cur.vector || { nodes: [], closed: true, inflate: (parseFloat(UI.vectorInflate?.value||'6')||6) };
      const vclone = { nodes: JSON.parse(JSON.stringify(vsrc.nodes||[])), closed: !!vsrc.closed, inflate: (vsrc.inflate ?? (parseFloat(UI.vectorInflate?.value||'6')||6)) };
      layouts.push({ id, name, points: clone, vector: vclone });
      setActiveLayout(layouts.length-1);
    }
    function renameActiveLayout(newName){ if(!newName) return; layouts[activeLayoutIndex].name = newName; refreshLayoutUI(); }
    function deleteActiveLayout(){ if(layouts.length<=1) return; layouts.splice(activeLayoutIndex,1); setActiveLayout(Math.max(0, activeLayoutIndex-1)); }

    function refreshLayoutUI(){
      if(!UI.layoutSelect) return;
      // Rebuild options
      UI.layoutSelect.innerHTML = '';
      layouts.forEach((l, i)=>{
        const opt = document.createElement('option');
        opt.value = String(i);
        opt.textContent = l.name || ('Layout '+(i+1));
        if(i===activeLayoutIndex) opt.selected = true;
        UI.layoutSelect.appendChild(opt);
      });
      // Controls
      if(UI.layoutDelete) UI.layoutDelete.disabled = layouts.length<=1;
    }
    let draggingIndex = -1; let isDragging = false; let selected = -1;
    // Vector state (per-layout via alias)
    /** @type {{x:number,y:number,type:'sharp'|'round',r:number}[]} */
    let vNodes = (layouts[activeLayoutIndex].vector && layouts[activeLayoutIndex].vector.nodes) ? layouts[activeLayoutIndex].vector.nodes : [];
    let vSelected = -1;
    let vectorClosed = (layouts[activeLayoutIndex].vector && typeof layouts[activeLayoutIndex].vector.closed==='boolean') ? layouts[activeLayoutIndex].vector.closed : true;
    let draggingVNode = -1; let isDraggingVNode = false;
    let draggingVHandle = false;
    // Pitlane state (vector nodes with per-corner radius)
    /** @type {{x:number,y:number,type:'sharp'|'round',r:number}[]} */
    let pitVNodes = [];
    let pitVSelected = -1;
    let pitVectorClosed = false; // pit is typically open
    let pitDraggingIndex = -1; let pitDragging = false; let pitSelected = -1; // legacy/mini state for compatibility
    // Start/Finish (vector node index; -1 = none)
    let startFinishVNode = -1;
    // Alternative track-click start/finish placement (world pos + tangent)
    let startFinishTrack = null; // {x:number,y:number,tx:number,ty:number}
    let sfPlaceArmed = false;

    // Undo/Redo system
    let history = [];
    let historyIndex = -1;
    const MAX_HISTORY = 50;

    function captureState() {
      const state = {
        // keep points for backward compat in history, but store full layouts
        points: JSON.parse(JSON.stringify(points)),
        layouts: JSON.parse(JSON.stringify(layouts)),
        activeLayoutIndex,
        pitVNodes: JSON.parse(JSON.stringify(pitVNodes)),
        pitVectorClosed: pitVectorClosed,
        selected: selected,
        vector: {
          nodes: JSON.parse(JSON.stringify(vNodes)),
          closed: vectorClosed,
          inflate: (layouts[activeLayoutIndex]?.vector?.inflate ?? (parseFloat(UI.vectorInflate?.value||'6')||6))
        },
        startFinishVNode: startFinishVNode,
        startFinishTrack: startFinishTrack ? { x:startFinishTrack.x, y:startFinishTrack.y, tx:startFinishTrack.tx, ty:startFinishTrack.ty } : null,
        settings: {
          closed: UI.closed.checked,
          usePerWidth: UI.usePerWidth.checked,
          usePerBank: UI.usePerBank.checked,
          globalWidth: parseFloat(UI.globalWidth.value),
          globalBank: parseFloat(UI.globalBank.value),
          autoBank: UI.autoBank.checked,
          tension: parseFloat(UI.tension?.value ?? 0),
          resolution: parseInt(UI.resolution.value),
          pitEnabled: UI.pitEnabled ? UI.pitEnabled.checked : false,
          pitWidth: UI.pitWidth ? parseFloat(UI.pitWidth.value) : 8,
          showAltOverlays: (document.getElementById('showAltOverlays')?.checked) || false,
          sfPreview: UI.sfPreview ? UI.sfPreview.checked : false
        }
      };
      return state;
    }

    function saveToHistory() {
      // Remove any future history if we're not at the end
      if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
      }
      
      // Add new state
      history.push(captureState());
      
      // Limit history size
      if (history.length > MAX_HISTORY) {
        history.shift();
      } else {
        historyIndex++;
      }
      
      updateUndoRedoButtons();
    }

    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        restoreState(history[historyIndex]);
        updateUndoRedoButtons();
      }
    }

    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        restoreState(history[historyIndex]);
        updateUndoRedoButtons();
      }
    }

    function restoreState(state) {
      layouts = Array.isArray(state.layouts) && state.layouts.length ? JSON.parse(JSON.stringify(state.layouts)) : [{ id:'L1', name:'Main', points: JSON.parse(JSON.stringify(state.points||[])), vector:{nodes:[],closed:true,inflate:6} }];
      // Ensure each layout has a vector object
      for(let i=0;i<layouts.length;i++){
        const L = layouts[i];
        if(!L.vector){ L.vector = { nodes: [], closed: true, inflate: (state?.vector?.inflate ?? 6) }; }
        L.vector.nodes = Array.isArray(L.vector.nodes) ? L.vector.nodes.map(n=>({x:+n.x||0,y:+n.y||0,type:(n.type==='round'?'round':'sharp'),r:Math.max(0,+n.r||0)})) : [];
        if(typeof L.vector.closed !== 'boolean') L.vector.closed = true;
        if(typeof L.vector.inflate !== 'number') L.vector.inflate = (state?.vector?.inflate ?? 6);
      }
      activeLayoutIndex = Math.max(0, Math.min(state.activeLayoutIndex||0, layouts.length-1));
      points = layouts[activeLayoutIndex].points;
      pitVNodes = Array.isArray(state.pitVNodes) ? JSON.parse(JSON.stringify(state.pitVNodes)) : [];
      pitVectorClosed = (typeof state.pitVectorClosed==='boolean') ? state.pitVectorClosed : false;
      selected = state.selected;
      // Vector (prefer per-layout; fall back to state.vector for backward compat)
      if(state.vector){
        const v = state.vector;
        if(Array.isArray(v.nodes)) layouts[activeLayoutIndex].vector.nodes = v.nodes.map(n=>({x:+n.x||0,y:+n.y||0,type:(n.type==='round'?'round':'sharp'),r:Math.max(0,+n.r||0)}));
        if(typeof v.closed==='boolean') layouts[activeLayoutIndex].vector.closed = v.closed;
        if(typeof v.inflate==='number') layouts[activeLayoutIndex].vector.inflate = v.inflate;
      }
      vNodes = layouts[activeLayoutIndex].vector.nodes;
      vectorClosed = layouts[activeLayoutIndex].vector.closed;
      if (UI.vectorInflate) UI.vectorInflate.value = String(layouts[activeLayoutIndex].vector.inflate ?? 6);
      // Start/Finish
      startFinishVNode = (typeof state.startFinishVNode === 'number') ? state.startFinishVNode : -1;
      startFinishTrack = state.startFinishTrack && typeof state.startFinishTrack.x==='number' ? {
        x:+state.startFinishTrack.x||0,
        y:+state.startFinishTrack.y||0,
        tx:+state.startFinishTrack.tx||1,
        ty:+state.startFinishTrack.ty||0
      } : null;
      // Reset transient interaction flags to avoid stuck input after undo/redo
      panning=false; isDragging=false; draggingIndex=-1; isDraggingVNode=false; draggingVNode=-1; draggingVHandle=false; 
      pitDragging=false; pitDraggingIndex=-1; 
      // Clear any modifier state that may be stuck
      for(const k in keys){ if(Object.prototype.hasOwnProperty.call(keys,k)) keys[k]=false; }
      
      // Restore settings
      UI.closed.checked = state.settings.closed;
      UI.usePerWidth.checked = state.settings.usePerWidth;
      UI.usePerBank.checked = state.settings.usePerBank;
      UI.globalWidth.value = state.settings.globalWidth;
      UI.globalBank.value = state.settings.globalBank;
      UI.autoBank.checked = state.settings.autoBank;
      if(UI.tension) UI.tension.value = state.settings.tension;
      UI.resolution.value = state.settings.resolution;
      if(UI.pitEnabled) UI.pitEnabled.checked = !!state.settings.pitEnabled;
      if(UI.pitWidth) UI.pitWidth.value = state.settings.pitWidth;
      if(UI.sfPreview) UI.sfPreview.checked = !!state.settings.sfPreview;
      const showAlt = state.settings.showAltOverlays;
      const chk = document.getElementById('showAltOverlays'); if(chk) chk.checked = !!showAlt;
      
      refreshLayoutUI();
      syncBadges();
      if(mode==='vector') syncSelectedVectorUI(); else syncSelectedUI();
      recompute();
      draw();
    }

    function updateUndoRedoButtons() {
      UI.undoBtn.disabled = historyIndex <= 0;
      UI.redoBtn.disabled = historyIndex >= history.length - 1;
    }

    function exportTrack() {
      const data = {
        version: "6.7.0",
        // Keep top-level points for backward compatibility (active layout)
        points: points,
        // New: layouts array (with per-layout vector)
        layouts: layouts.map(l=>({
          id: l.id,
          name: l.name,
          points: l.points,
          vector: l.vector ? {
            nodes: (l.vector.nodes||[]).map(n=>({x:n.x,y:n.y,type:n.type,r:n.r})),
            closed: !!l.vector.closed,
            inflate: (l.vector.inflate ?? 6)
          } : { nodes: [], closed: true, inflate: 6 }
        })),
        activeLayoutIndex,
      pitlane: (function(){
          // Export sampled pit centerline from pit vector nodes for compatibility
          const enabled = UI.pitEnabled ? !!UI.pitEnabled.checked : false;
          const width = UI.pitWidth ? parseFloat(UI.pitWidth.value) : 8;
          const res = Math.max(32, Math.floor(parseInt(UI.resolution.value,10)/2));
          const center = (pitVNodes.length>=2) ? (function(){
            // sample pit vector polyline with arcs
            const n=pitVNodes.length; const infos=new Array(n); for(let i=0;i<n;i++) infos[i]=computeCornerInfoFor(pitVNodes, pitVectorClosed, i);
            const out=[]; const start=infos[0]; const startP=(start&&start.valid)? start.T1 : {x:pitVNodes[0].x, y:pitVNodes[0].y}; out.push(startP);
            const segRes=Math.max(2, Math.floor(res/50));
            for(let i=0;i<n;i++){
              const inf=infos[i];
              if(inf && inf.valid){ let a1=inf.a1, a2=inf.a2; if(inf.ccw){ while(a2>a1) a2-=Math.PI*2; } else { while(a2<a1) a2+=Math.PI*2; }
                const delta=a2-a1; const steps=Math.max(2, Math.min(64, Math.floor(Math.abs(delta)/(Math.PI/segRes))+1));
                for(let k=1;k<=steps;k++){ const ang=a1 + delta*(k/steps); out.push({x:inf.center.x + Math.cos(ang)*inf.r, y:inf.center.y + Math.sin(ang)*inf.r}); }
              } else { out.push({x:pitVNodes[i].x, y:pitVNodes[i].y}); }
              const next=infos[(i+1)%n]; const hasNext=pitVectorClosed? true : (i+1<n); if(!hasNext) break; const nextP=(next&&next.valid)? next.T1 : {x:pitVNodes[(i+1)%n].x, y:pitVNodes[(i+1)%n].y}; out.push(nextP);
            }
            return out;
          })() : [];
          return { enabled, width, points: center };
        })(),
        // Also keep top-level vector (active layout) and start/finish marker
        vector: (function(){
          const av = layouts[activeLayoutIndex]?.vector || { nodes: [], closed: true, inflate: (parseFloat(UI.vectorInflate?.value||'6')||6) };
          return {
            nodes: (av.nodes||[]).map(n=>({x:n.x,y:n.y,type:n.type,r:n.r})),
            closed: !!av.closed,
            inflate: (av.inflate ?? 6)
          };
        })(),
        startFinish: (function(){
          const obj = {};
          if(startFinishVNode>=0) obj.vectorIndex = startFinishVNode;
          if(startFinishTrack){ obj.track = { x:startFinishTrack.x, y:startFinishTrack.y, tx:startFinishTrack.tx, ty:startFinishTrack.ty }; }
          return Object.keys(obj).length? obj : null;
        })(),
        settings: {
          closed: UI.closed.checked,
          usePerWidth: UI.usePerWidth.checked,
          usePerBank: UI.usePerBank.checked,
          globalWidth: parseFloat(UI.globalWidth.value),
          globalBank: parseFloat(UI.globalBank.value),
          autoBank: UI.autoBank.checked,
          autoStrength: parseFloat(UI.autoStrength.value),
          autoMax: parseFloat(UI.autoMax.value),
          smoothBank: UI.smoothBank.checked,
          showBankViz: UI.showBankViz.checked,
          tension: parseFloat(UI.tension?.value ?? 0),
          resolution: parseInt(UI.resolution.value),
          snap: UI.snap.checked,
          grid: parseInt(UI.grid.value),
          showCtrl: UI.showCtrl.checked,
          showAltOverlays: (document.getElementById('showAltOverlays')?.checked) || false,
          sfPreview: UI.sfPreview ? UI.sfPreview.checked : false
        }
      };
      
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `track-${new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-')}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function importTrack(file) {
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          
          // Save current state before importing
          saveToHistory();
          
          // Import layouts (new) or fallback to points (old)
          if (Array.isArray(data.layouts) && data.layouts.length) {
            layouts = data.layouts.map((l, i) => ({
              id: l.id || ('L'+(i+1)),
              name: l.name || ('Layout '+(i+1)),
              points: Array.isArray(l.points) ? l.points.map(p=>({x:+p.x||0,y:+p.y||0,t:+p.t||0,tb:+p.tb||0,w:+p.w||12,b:+p.b||0,c:!!p.c})) : [],
              vector: l.vector ? {
                nodes: Array.isArray(l.vector.nodes) ? l.vector.nodes.map(n=>({x:+n.x||0,y:+n.y||0,type:(n.type==='round'?'round':'sharp'),r:Math.max(0,+n.r||0)})) : [],
                closed: (typeof l.vector.closed==='boolean') ? l.vector.closed : true,
                inflate: (typeof l.vector.inflate==='number') ? l.vector.inflate : (data?.vector?.inflate ?? 6)
              } : { nodes: [], closed: true, inflate: (data?.vector?.inflate ?? 6) }
            }));
            activeLayoutIndex = Math.max(0, Math.min(data.activeLayoutIndex||0, layouts.length-1));
          } else if (Array.isArray(data.points)) {
            // Backward compat: single layout
            const defInfl = (data?.vector?.inflate ?? 6);
            const L0 = { id:'L1', name:'Main', points: data.points.map(p => ({ x:+p.x||0, y:+p.y||0, t:+p.t||0, tb:+p.tb||0, w:+p.w||12, b:+p.b||0, c:!!p.c })), vector:{ nodes: [], closed: true, inflate: defInfl } };
            // If top-level vector exists, assign to this layout
            if (data.vector && Array.isArray(data.vector.nodes)) {
              L0.vector.nodes = data.vector.nodes.map(n=>({x:+n.x||0,y:+n.y||0,type:(n.type==='round'?'round':'sharp'),r:Math.max(0,+n.r||0)}));
              if (typeof data.vector.closed==='boolean') L0.vector.closed = data.vector.closed;
              if (typeof data.vector.inflate==='number') L0.vector.inflate = data.vector.inflate;
            }
            layouts = [L0];
            activeLayoutIndex = 0;
          } else {
            layouts = [{ id:'L1', name:'Main', points: [], vector:{ nodes: [], closed: true, inflate: (data?.vector?.inflate ?? 6) } }];
            activeLayoutIndex = 0;
          }
          points = layouts[activeLayoutIndex].points;
          // Ensure UI and aliases reflect the active layout vector
          vNodes = layouts[activeLayoutIndex].vector.nodes;
          vectorClosed = layouts[activeLayoutIndex].vector.closed;
          if (UI.vectorInflate) UI.vectorInflate.value = String(layouts[activeLayoutIndex].vector.inflate ?? 6);
          // Import pitlane if present (vector-style if nodes available)
          if (data.pitlane) {
            if (Array.isArray(data.pitlane.nodes)) {
              pitVNodes = data.pitlane.nodes.map(n=>({ x:+n.x||0, y:+n.y||0, type:(n.type==='round'?'round':'sharp'), r:Math.max(0,+n.r||0) }));
              pitVectorClosed = !!data.pitlane.closed;
            } else if (Array.isArray(data.pitlane.points)) {
              // Back-compat: convert plain points to sharp nodes
              pitVNodes = data.pitlane.points.map(p=>({ x:+p.x||0, y:+p.y||0, type:'sharp', r:0 }));
              pitVectorClosed = false;
            } else { pitVNodes = []; pitVectorClosed=false; }
            if(UI.pitEnabled) UI.pitEnabled.checked = !!data.pitlane.enabled;
            if(UI.pitWidth && data.pitlane.width!=null) UI.pitWidth.value = data.pitlane.width;
          }
          // Import start/finish if present
          if (data.startFinish){
            if (typeof data.startFinish.vectorIndex === 'number') {
              startFinishVNode = Math.max(-1, Math.min(data.startFinish.vectorIndex|0, (layouts[activeLayoutIndex].vector.nodes||[]).length-1));
            } else { startFinishVNode = -1; }
            if (data.startFinish.track && typeof data.startFinish.track.x==='number'){
              startFinishTrack = {
                x:+data.startFinish.track.x||0,
                y:+data.startFinish.track.y||0,
                tx:+data.startFinish.track.tx||1,
                ty:+data.startFinish.track.ty||0
              };
            } else { startFinishTrack = null; }
          } else {
            startFinishVNode = -1; startFinishTrack = null;
          }
          
          // Import settings if available
          if (data.settings) {
            const s = data.settings;
            if (s.closed !== undefined) UI.closed.checked = s.closed;
            if (s.usePerWidth !== undefined) UI.usePerWidth.checked = s.usePerWidth;
            if (s.usePerBank !== undefined) UI.usePerBank.checked = s.usePerBank;
            if (s.globalWidth !== undefined) UI.globalWidth.value = s.globalWidth;
            if (s.globalBank !== undefined) UI.globalBank.value = s.globalBank;
            if (s.autoBank !== undefined) UI.autoBank.checked = s.autoBank;
            if (s.autoStrength !== undefined) UI.autoStrength.value = s.autoStrength;
            if (s.autoMax !== undefined) UI.autoMax.value = s.autoMax;
            if (s.smoothBank !== undefined) UI.smoothBank.checked = s.smoothBank;
            if (s.showBankViz !== undefined) UI.showBankViz.checked = s.showBankViz;
            if (s.tension !== undefined && UI.tension) UI.tension.value = s.tension;
            if (s.resolution !== undefined) UI.resolution.value = s.resolution;
            if (s.snap !== undefined) UI.snap.checked = s.snap;
            if (s.grid !== undefined) UI.grid.value = s.grid;
            if (s.showCtrl !== undefined) UI.showCtrl.checked = s.showCtrl;
            const chk = document.getElementById('showAltOverlays');
            if (chk && s.showAltOverlays !== undefined) chk.checked = !!s.showAltOverlays;
          }
          
          selected = -1; vSelected = -1;
          refreshLayoutUI();
          syncBadges();
          if(mode==='vector') syncSelectedVectorUI(); else syncSelectedUI();
          recompute();
          fitToScreen();
          draw();
          
        } catch (error) {
          alert('Error importing track: ' + error.message);
        }
      };
      reader.readAsText(file);
    }

    // Smoothed cache with segment mapping
    let smoothCache = { pts: [], segOf: [], tInSeg: [] };

    // View transform
    const view = { x: 0, y: 0, z: 1 };

    // ===== ResizeObserver fix: debounce via rAF =====
    function doResize(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      const w = Math.floor(rect.width * dpr);
      const h = Math.floor(rect.height * dpr);
      if (canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h; ctx.setTransform(dpr,0,0,dpr,0,0);
      } else {
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }
      draw();
    }
    let roPending=false;
    const ro = new ResizeObserver(()=>{
      if(roPending) return; roPending=true;
      requestAnimationFrame(()=>{ roPending=false; doResize(); });
    });
    ro.observe(canvas);
    window.addEventListener('orientationchange', ()=>requestAnimationFrame(doResize));

    // Coords helpers
    function screenToWorld(sx, sy){ const r=canvas.getBoundingClientRect(); const x=sx-r.left, y=sy-r.top; return { x:(x-r.width/2)/view.z - view.x, y:(y-r.height/2)/view.z - view.y } }
    function worldToScreen(p){ const r=canvas.getBoundingClientRect(); return { x:(p.x+view.x)*view.z + r.width/2, y:(p.y+view.y)*view.z + r.height/2 } }
    function getMouseWorld(e){ return screenToWorld(e.clientX, e.clientY) }

    // Hit testing
    function hitTestPoint(worldPt, pxRadius=8){ let idx=-1, best=(pxRadius/view.z)*(pxRadius/view.z); for(let i=0;i<points.length;i++){ const dx=worldPt.x-points[i].x, dy=worldPt.y-points[i].y, d2=dx*dx+dy*dy; if(d2<best){ best=d2; idx=i } } return idx }
    function nearestControlSegment(worldPt){ if(points.length<2) return {idx:-1,q:null,d:1e9}; const count=UI.closed.checked?points.length:points.length-1; let best=1e9,bestIdx=-1,bestQ=null; for(let i=0;i<count;i++){ const a=points[i], b=points[(i+1)%points.length]; const abx=b.x-a.x, aby=b.y-a.y; const t=Math.max(0,Math.min(1,((worldPt.x-a.x)*abx+(worldPt.y-a.y)*aby)/(abx*abx+aby*aby||1))); const q={x:a.x+abx*t,y:a.y+aby*t}; const d=Math.hypot(worldPt.x-q.x, worldPt.y-q.y); if(d<best){best=d; bestIdx=i; bestQ=q} } return {idx:bestIdx,q:bestQ,d:best} }
    // Vector hit testing
    function hitTestVNode(worldPt, pxRadius=8){ let idx=-1, best=(pxRadius/view.z)*(pxRadius/view.z); for(let i=0;i<vNodes.length;i++){ const dx=worldPt.x-vNodes[i].x, dy=worldPt.y-vNodes[i].y, d2=dx*dx+dy*dy; if(d2<best){ best=d2; idx=i } } return idx }
    function nearestVectorSegment(worldPt){ const n=vNodes.length; const closed=vectorClosed; const segCount = closed? n : Math.max(0,n-1); if(n<2) return {idx:-1,q:null,d:1e9}; let best=1e9,bestIdx=-1,bestQ=null; for(let i=0;i<segCount;i++){ const a=vNodes[i], b=vNodes[(i+1)%n]; const abx=b.x-a.x, aby=b.y-a.y; const t=Math.max(0,Math.min(1,((worldPt.x-a.x)*abx+(worldPt.y-a.y)*aby)/(abx*abx+aby*aby||1))); const q={x:a.x+abx*t,y:a.y+aby*t}; const d=Math.hypot(worldPt.x-q.x, worldPt.y-q.y); if(d<best){best=d; bestIdx=i; bestQ=q} } return {idx:bestIdx,q:bestQ,d:best} }
    function pitHitTestVNode(worldPt, pxRadius=8){ let idx=-1, best=(pxRadius/view.z)*(pxRadius/view.z); for(let i=0;i<pitVNodes.length;i++){ const dx=worldPt.x-pitVNodes[i].x, dy=worldPt.y-pitVNodes[i].y, d2=dx*dx+dy*dy; if(d2<best){ best=d2; idx=i } } return idx }
    function pitNearestVectorSegment(worldPt){ const n=pitVNodes.length; const closed=pitVectorClosed; const segCount=closed? n : Math.max(0,n-1); if(n<2) return {idx:-1,q:null,d:1e9}; let best=1e9,bestIdx=-1,bestQ=null; for(let i=0;i<segCount;i++){ const a=pitVNodes[i], b=pitVNodes[(i+1)%n]; const abx=b.x-a.x, aby=b.y-a.y; const t=Math.max(0,Math.min(1,((worldPt.x-a.x)*abx+(worldPt.y-a.y)*aby)/(abx*abx+aby*aby||1))); const q={x:a.x+abx*t,y:a.y+aby*t}; const d=Math.hypot(worldPt.x-q.x, worldPt.y-q.y); if(d<best){best=d; bestIdx=i; bestQ=q} } return {idx:bestIdx,q:bestQ,d:best} }
    function nearestSmoothed(worldPt){ const pts=smoothCache.pts,map=smoothCache.segOf; if(pts.length<2) return {i:-1,q:null,d:1e9}; let best=1e9,bestI=-1,bestQ=null; for(let i=0;i<pts.length-1;i++){ const a=pts[i], b=pts[i+1]; const abx=b.x-a.x, aby=b.y-a.y; const t=Math.max(0,Math.min(1,((worldPt.x-a.x)*abx+(worldPt.y-a.y)*aby)/(abx*abx+aby*aby||1))); const q={x:a.x+abx*t,y:a.y+aby*t}; const d=Math.hypot(worldPt.x-q.x, worldPt.y-q.y); if(d<best){best=d; bestI=i; bestQ=q} } return {i:bestI,q:bestQ,d:best, seg: bestI>=0? map[bestI]:-1} }

    function snapIf(p){ if(!UI.snap.checked) return p; const g=parseFloat(UI.grid.value)||24; return {x:Math.round(p.x/g)*g, y:Math.round(p.y/g)*g} }
    function decimate(pts, step, minSpacing){ const out=[]; let last=null; for(let i=0;i<pts.length;i+=Math.max(1,step)){ const p=pts[i]; if(!last || Math.hypot(p.x-last.x,p.y-last.y)>=minSpacing){ out.push({x:p.x,y:p.y}); last=p; } } if(out.length>1 && (out[0].x!==pts[0].x || out[0].y!==pts[0].y)) out.unshift({x:pts[0].x,y:pts[0].y}); return out; }
    function angleBetween(u,v){ const d=(u.x*v.x+u.y*v.y)/Math.max(1e-6, Math.hypot(u.x,u.y)*Math.hypot(v.x,v.y)); return Math.acos(Math.max(-1,Math.min(1,d))); }

    // ===== Vector geometry =====
    function buildFixedOffset(center, inflate){ if(center.length<2) return {left:[],right:[]}; const left=[], right=[]; const n=center.length; for(let i=0;i<n;i++){ const p=center[i]; const pm=center[(i-1+n)%n]; const pp=center[(i+1)%n]; const tx=pp.x-pm.x, ty=pp.y-pm.y; const len=Math.hypot(tx,ty)||1; const nx=-ty/len, ny=tx/len; const hw = inflate; left.push({x:p.x+nx*hw, y:p.y+ny*hw}); right.push({x:p.x-nx*hw, y:p.y-ny*hw}); } return {left,right}; }
    function buildOutlineFromCenterline(){ const center = smoothCache.pts; if(center.length<2) return; const step=Math.max(6, Math.floor(parseInt(UI.resolution.value,10)/20)); const minSpacing=4; const samples = decimate(center, step, minSpacing); const inflate = Math.max(0, parseFloat(UI.vectorInflate?.value||'0')||0); const off = buildFixedOffset(samples, inflate); const poly = off.left.concat(off.right.slice().reverse()); vNodes.length = 0; for(const p of poly){ vNodes.push({x:p.x,y:p.y,type:'sharp',r:0}); } vectorClosed = true; if(layouts[activeLayoutIndex]?.vector) layouts[activeLayoutIndex].vector.closed = true; vSelected = -1; syncSelectedVectorUI(); }
    function clampRadiusForNode(i, desired){ const n=vNodes.length; if(n<3) return 0; const B=vNodes[i]; const A=vNodes[(i-1+n)%n]; const C=vNodes[(i+1)%n]; const ba={x:A.x-B.x,y:A.y-B.y}; const bc={x:C.x-B.x,y:C.y-B.y}; const l1=Math.hypot(ba.x,ba.y), l2=Math.hypot(bc.x,bc.y); if(l1<1e-6 || l2<1e-6) return 0; const u1={x:ba.x/l1,y:ba.y/l1}; const u2={x:bc.x/l2,y:bc.y/l2}; const theta = angleBetween(u1,u2); const half = theta*0.5; const tanh = Math.tan(half); if(tanh<=1e-6) return 0; const maxD = Math.min(0.4*l1, 0.4*l2); const d = Math.min(desired/Math.max(1e-6,tanh), maxD); return d * tanh; }
    function computeCornerInfo(i){
      const n=vNodes.length; if(n<3) return null;
      const B=vNodes[i]; const A=vNodes[(i-1+n)%n]; const C=vNodes[(i+1)%n];
      const ba={x:A.x-B.x,y:A.y-B.y}; const bc={x:C.x-B.x,y:C.y-B.y};
      const l1=Math.hypot(ba.x,ba.y), l2=Math.hypot(bc.x,bc.y);
      if(l1<1e-6 || l2<1e-6) return null;
      const u1={x:ba.x/l1,y:ba.y/l1}; const u2={x:bc.x/l2,y:bc.y/l2};
      const theta = angleBetween(u1,u2); const half = theta*0.5; const tanh = Math.tan(half);
      if(!(vNodes[i].type==='round') || (vNodes[i].r||0)<=0 || tanh<=1e-6){
        return {valid:false, T1:B, T2:B, r:0, bisector:null};
      }
      const desiredR = vNodes[i].r||0; const maxD = Math.min(0.4*l1, 0.4*l2);
      let d = desiredR/Math.max(1e-6,tanh); if(d>maxD) d=maxD;
      const rEff = d*tanh;
      const T1={x:B.x+u1.x*d,y:B.y+u1.y*d};
      const T2={x:B.x+u2.x*d,y:B.y+u2.y*d};
      // normalized angle bisector towards inside corner
      const bisRaw={x:u1.x+u2.x, y:u1.y+u2.y}; const bisLen=Math.hypot(bisRaw.x,bisRaw.y)||1; const bis={x:bisRaw.x/bisLen, y:bisRaw.y/bisLen};
      const h = rEff/Math.max(1e-6, Math.sin(half));
      const center={x:B.x+bis.x*h, y:B.y+bis.y*h};
      const a1=Math.atan2(T1.y-center.y, T1.x-center.x);
      const a2=Math.atan2(T2.y-center.y, T2.x-center.x);
      const cross = u1.x*u2.y - u1.y*u2.x; const ccw = cross>0; // left turn -> ccw
      return {valid:true, T1, T2, center, r:rEff, a1, a2, ccw, bisector:bis};
    }
    function getVectorHandle(i){ const info=computeCornerInfo(i); if(!info || !info.bisector) return null; const B=vNodes[i]; const r = Math.max(0, vNodes[i].r||0); const pos={x:B.x+info.bisector.x*r, y:B.y+info.bisector.y*r}; return pos; }
    // Generic helpers to draw curved vector paths for arbitrary node arrays (for overlays)
    function computeCornerInfoFor(nodes, closed, i){
      const n = nodes.length; if(n<3) return null;
      const get = (j)=> closed ? nodes[(j+n)%n] : (j<0||j>=n? null : nodes[j]);
      const B = nodes[i], A = get(i-1), C = get(i+1);
      if(!A || !C) return {valid:false, T1:B, T2:B, r:0, bisector:null};
      const ba={x:A.x-B.x,y:A.y-B.y}, bc={x:C.x-B.x,y:C.y-B.y};
      const l1=Math.hypot(ba.x,ba.y), l2=Math.hypot(bc.x,bc.y); if(l1<1e-6||l2<1e-6) return {valid:false, T1:B, T2:B, r:0, bisector:null};
      const u1={x:ba.x/l1,y:ba.y/l1}, u2={x:bc.x/l2,y:bc.y/l2};
      const theta = angleBetween(u1,u2); const half = theta*0.5; const tanh = Math.tan(half);
      const desiredR = Math.max(0, nodes[i].type==='round' ? (nodes[i].r||0) : 0);
      if(desiredR<=0 || tanh<=1e-6){ return {valid:false, T1:B, T2:B, r:0, bisector:null}; }
      const maxD = Math.min(0.4*l1, 0.4*l2);
      let d = desiredR/Math.max(1e-6,tanh); if(d>maxD) d=maxD;
      const rEff = d*tanh;
      const T1={x:B.x+u1.x*d,y:B.y+u1.y*d};
      const T2={x:B.x+u2.x*d,y:B.y+u2.y*d};
      const bisRaw={x:u1.x+u2.x,y:u1.y+u2.y}; const bisLen=Math.hypot(bisRaw.x,bisRaw.y)||1; const bis={x:bisRaw.x/bisLen,y:bisRaw.y/bisLen};
      const h = rEff/Math.max(1e-6, Math.sin(half));
      const center={x:B.x+bis.x*h, y:B.y+bis.y*h};
      const a1=Math.atan2(T1.y-center.y, T1.x-center.x);
      const a2=Math.atan2(T2.y-center.y, T2.x-center.x);
      const cross = u1.x*u2.y - u1.y*u2.x; const ccw = cross>0;
      return {valid:true, T1, T2, center, r:rEff, a1, a2, ccw, bisector:bis};
    }
    function strokeVectorOutline(nodes, closed, color, width=2, dash=[6,4], alpha=0.65){
      const n = nodes.length; if(n<2) return;
      const infos = new Array(n);
      for(let i=0;i<n;i++) infos[i] = computeCornerInfoFor(nodes, closed, i);
      ctx.save();
      if(dash) ctx.setLineDash(dash); else ctx.setLineDash([]);
      ctx.globalAlpha = alpha; ctx.strokeStyle = color; ctx.lineWidth = width;
      ctx.beginPath();
      const start = infos[0];
      const startP = (start && start.valid) ? start.T1 : {x:nodes[0].x, y:nodes[0].y};
      let sp = worldToScreen(startP); ctx.moveTo(sp.x, sp.y);
      for(let i=0;i<n;i++){
        const inf = infos[i];
        if(inf && inf.valid){
          const c = worldToScreen(inf.center);
          const r = inf.r * view.z;
          ctx.arc(c.x, c.y, r, inf.a1, inf.a2, inf.ccw);
        } else {
          const p = worldToScreen({x:nodes[i].x, y:nodes[i].y});
          ctx.lineTo(p.x, p.y);
        }
        const next = infos[(i+1)%n];
        const nextIdx = (i+1);
        const hasNext = closed ? true : (nextIdx < n);
        if(!hasNext) break;
        const nextP = (next && next.valid) ? next.T1 : {x:nodes[(i+1)%n].x, y:nodes[(i+1)%n].y};
        const np = worldToScreen(nextP); ctx.lineTo(np.x, np.y);
      }
      if(closed) ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }
    function clampRadiusForNodeIn(nodes, i, desired){ const n=nodes.length; if(n<3) return 0; const B=nodes[i]; const A=nodes[(i-1+n)%n]; const C=nodes[(i+1)%n]; const ba={x:A.x-B.x,y:A.y-B.y}; const bc={x:C.x-B.x,y:C.y-B.y}; const l1=Math.hypot(ba.x,ba.y), l2=Math.hypot(bc.x,bc.y); if(l1<1e-6 || l2<1e-6) return 0; const u1={x:ba.x/l1,y:ba.y/l1}; const u2={x:bc.x/l2,y:bc.y/l2}; const theta=angleBetween(u1,u2); const half=theta*0.5; const tanh=Math.tan(half); if(tanh<=1e-6) return 0; const maxD=Math.min(0.4*l1,0.4*l2); const d=Math.min(desired/Math.max(1e-6,tanh), maxD); return d*tanh; }
    function drawVector(){
      if(vNodes.length<2){ if(mode==='vector'){ const hint = UI.vectorFromTrack && UI.vectorFromTrack.checked? 'toggle off to draw manually' : 'Right‚Äëclick add ‚Ä¢ Shift+Right insert'; hud.textContent = `mode vector | nodes 0 | closed ${vectorClosed} | sel ‚Äî r=‚Äî type=‚Äî | inflate ${UI.vectorInflate?UI.vectorInflate.value:0} | ${hint}`; } return; }
      const n=vNodes.length; const trackColor = getComputedStyle(document.documentElement).getPropertyValue('--track') || '#2a3347'; const edgeColor = getComputedStyle(document.documentElement).getPropertyValue('--edge') || '#ffffff';
      const infos=new Array(n);
      for(let i=0;i<n;i++) infos[i]=computeCornerInfo(i);
      // Path with arcs
      ctx.beginPath();
      const start = infos[0];
      const startP = (start && start.valid) ? start.T1 : {x:vNodes[0].x, y:vNodes[0].y};
      let sp=worldToScreen(startP); ctx.moveTo(sp.x,sp.y);
      for(let i=0;i<n;i++){
        const inf = infos[i];
        if(inf && inf.valid){
          const c = worldToScreen(inf.center);
          const r = inf.r * view.z;
          ctx.arc(c.x, c.y, r, inf.a1, inf.a2, inf.ccw);
        } else {
          const p = worldToScreen({x:vNodes[i].x,y:vNodes[i].y});
          ctx.lineTo(p.x,p.y);
        }
        const next = infos[(i+1)%n];
        const nextP = (next && next.valid) ? next.T1 : {x:vNodes[(i+1)%n].x, y:vNodes[(i+1)%n].y};
        const np = worldToScreen(nextP); ctx.lineTo(np.x,np.y);
      }
      if(vectorClosed) ctx.closePath();
      // Fill (slightly translucent) then stroke (stroke width scales with global width)
      ctx.save(); ctx.globalAlpha = 0.85; ctx.fillStyle = trackColor; ctx.fill(); ctx.restore();
      const wScale = Math.max(1, Math.min(14, (parseFloat(UI.globalWidth?.value)||12)/4));
      ctx.strokeStyle = edgeColor; ctx.lineWidth = wScale; ctx.stroke();
      if(!previewMode){
        // Nodes
        for(let i=0;i<n;i++){
          const p=worldToScreen(vNodes[i]);
          ctx.beginPath(); ctx.arc(p.x,p.y, i===vSelected?7:5, 0, Math.PI*2);
          ctx.fillStyle = i===vSelected? '#71f9a8' : '#ffffff'; ctx.strokeStyle='rgba(0,0,0,0.5)'; ctx.lineWidth=2; ctx.fill(); ctx.stroke();
        }
        if(UI.showCornerHandles && UI.showCornerHandles.checked && vSelected>=0){ const h = getVectorHandle(vSelected); if(h){ const hs=worldToScreen(h); const sz=6; ctx.beginPath(); ctx.moveTo(hs.x, hs.y-sz); ctx.lineTo(hs.x+sz, hs.y); ctx.lineTo(hs.x, hs.y+sz); ctx.lineTo(hs.x-sz, hs.y); ctx.closePath(); ctx.fillStyle='#ffd166'; ctx.strokeStyle='rgba(0,0,0,0.5)'; ctx.lineWidth=2; ctx.fill(); ctx.stroke(); const bp=worldToScreen(vNodes[vSelected]); ctx.strokeStyle='rgba(255,209,102,0.5)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(bp.x,bp.y); ctx.lineTo(hs.x,hs.y); ctx.stroke(); } }
        // Start/Finish marker overlay (node-based)
        if(startFinishVNode>=0 && startFinishVNode<n){
          const i = startFinishVNode; const j = (i+1 < n) ? i+1 : (vectorClosed ? 0 : i);
          const A=vNodes[i], B=vNodes[j]; let tx=B.x-A.x, ty=B.y-A.y; const L=Math.hypot(tx,ty)||1; tx/=L; ty/=L; const nx=-ty, ny=tx; const half=(parseFloat(UI.globalWidth?.value)||12)*0.5;
          const Lp={x:A.x+nx*half, y:A.y+ny*half}, Rp={x:A.x-nx*half, y:A.y-ny*half}; const ls=worldToScreen(Lp), rs=worldToScreen(Rp);
          ctx.save(); ctx.strokeStyle='#ffffff'; ctx.lineWidth=3; ctx.setLineDash([6,4]); ctx.beginPath(); ctx.moveTo(ls.x,ls.y); ctx.lineTo(rs.x,rs.y); ctx.stroke(); ctx.setLineDash([]); ctx.restore();
        }
        // Start/Finish marker overlay (track-click-based)
        if(!isNaN(startFinishVNode) && startFinishVNode<0 && startFinishTrack){
          const tx = startFinishTrack.tx || 1, ty = startFinishTrack.ty || 0; const nx=-ty, ny=tx; const half=(parseFloat(UI.globalWidth?.value)||12)*0.5; const A={x:startFinishTrack.x,y:startFinishTrack.y};
          const Lp={x:A.x+nx*half, y:A.y+ny*half}, Rp={x:A.x-nx*half, y:A.y-ny*half}; const ls=worldToScreen(Lp), rs=worldToScreen(Rp);
          ctx.save(); ctx.strokeStyle='#ffffff'; ctx.lineWidth=3; ctx.setLineDash([6,4]); ctx.beginPath(); ctx.moveTo(ls.x,ls.y); ctx.lineTo(rs.x,rs.y); ctx.stroke(); ctx.setLineDash([]); ctx.restore();
        }
      }
    }

    // ===== AI Track Generator =====
    function rng(seed){ let s = Math.floor(seed) || Math.floor(Math.random()*1e9); return ()=>{ s = (s*1664525 + 1013904223)>>>0; return s/0x100000000; }; }
    const TWO_PI = Math.PI*2;
    function randn(r){ // approx normal via CLT
      let x=0; for(let i=0;i<6;i++) x += r(); return (x/6)-0.5; // ~[-0.5,0.5]
    }
    function pick(r, arr){ return arr[Math.floor(r()*arr.length)] }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function orient(a,b,c){ return (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x); }
    function segsIntersect(a,b,c,d){
      const o1=orient(a,b,c), o2=orient(a,b,d), o3=orient(c,d,a), o4=orient(c,d,b);
      if((o1===0&&onSeg(a,b,c))||(o2===0&&onSeg(a,b,d))||(o3===0&&onSeg(c,d,a))||(o4===0&&onSeg(c,d,b))) return true;
      return (o1>0)!==(o2>0) && (o3>0)!==(o4>0);
      function onSeg(p,q,r){ return Math.min(p.x,q.x)-1e-6<=r.x && r.x<=Math.max(p.x,q.x)+1e-6 && Math.min(p.y,q.y)-1e-6<=r.y && r.y<=Math.max(p.y,q.y)+1e-6; }
    }
    function wouldSelfIntersect(poly, candidate){
      const n=poly.length; if(n<2) return false; const a=poly[n-1]; const b=candidate; // check against all but adjacent last segment
      for(let i=0;i<n-2;i++){ const c=poly[i], d=poly[i+1]; if(segsIntersect(a,b,c,d)) return true; }
      return false;
    }

    function generateTrack({km=5.0, style='balanced', discipline='F1', seed}={}){
      const r = rng(seed||Date.now());
      // Targets
      const targetLen = km*1000;
      // Aim for 15‚Äì25 total points. With 2 points per corner (+start/close), corners ~ 7‚Äì11.
      const targetPoints = clamp(Math.round((km/5.0)*20), 16, 24);
      let targetCorners = clamp(Math.floor((targetPoints-2)/2), 7, 11);
      // Style weights
      const styles = {
        balanced: { slow:0.28, med:0.42, fast:0.30, longStraight:0.08 },
        flow:     { slow:0.18, med:0.40, fast:0.42, longStraight:0.09 },
        technical:{ slow:0.38, med:0.42, fast:0.20, longStraight:0.05 },
        speed:    { slow:0.20, med:0.36, fast:0.44, longStraight:0.10 },
      };
      const W = styles[style] || styles.balanced;
      const wantSlow = Math.max(2, Math.round(targetCorners*W.slow));
      const wantMed  = Math.max(3, Math.round(targetCorners*W.med));
      const wantFast = Math.max(2, Math.round(targetCorners*W.fast));
      // Build a loop by walking headings with varied turns and straight runs
      let pts = [{x:0,y:0}];
      let kinds = ['straight']; // label each added point as 'straight' or 'corner'
      let heading = r()*TWO_PI;
      const segs = [];
      const centerBias = ()=>({x: -0.002*pts[pts.length-1].x, y: -0.002*pts[pts.length-1].y});
      // Recipes for segments
      const cornerDefs = {
        slow:   ()=>({ dTheta:(0.85+0.45*r())*pick(r,[1,-1]), lenFrac: 0.030 + 0.010*r() }),
        medium: ()=>({ dTheta:(0.50+0.30*r())*pick(r,[1,-1]), lenFrac: 0.040 + 0.015*r() }),
        fast:   ()=>({ dTheta:(0.25+0.18*r())*pick(r,[1,-1]), lenFrac: 0.055 + 0.020*r() })
      };
      const straightFrac = ()=> 0.025 + 0.020*r(); // 2.5%..4.5% of lap
      // Compose sequence ensuring variety and breathers
      let cs={slow:0,med:0,fast:0};
      while(cs.slow+cs.med+cs.fast < targetCorners){
        const pickType = ()=>{
          const order = ['slow','medium','fast'];
          order.sort(()=>r()-0.5);
          for(const t of order){ if(cs[t] < (t==='slow'?wantSlow:(t==='medium'?wantMed:wantFast))) return t; }
          return pick(r, order);
        }
        const t = pickType();
        const def = cornerDefs[t]();
        segs.push({type:'straight', frac: straightFrac()});
        segs.push({type:'corner', kind:t, dTheta:def.dTheta, frac:def.lenFrac});
        cs[t]++;
      }
      // Add a signature long straight by boosting one existing straight (don‚Äôt add extra segments)
      const sigStraightFrac = W.longStraight; // fraction of lap length
      if(sigStraightFrac > 0){
        // find a straight to boost ‚Äî pick one of the earlier ones
        const indices = segs.map((s,i)=>({s,i})).filter(o=>o.s.type==='straight').map(o=>o.i);
        if(indices.length){ const j = indices[Math.floor(r()*indices.length)]; segs[j].frac = Math.min((segs[j].frac||0)+Math.min(0.10, sigStraightFrac), 0.10); }
      }

      // Convert fracs to lengths that sum near target
      const sumFrac = segs.reduce((a,s)=>a+(s.frac||0),0) || 1;
      const scaleL = targetLen / sumFrac;

      // Walk and create control points at segment transitions (one point per segment)
      const MAX_STRAIGHT_FRAC = 0.08; // cap any straight to 8% of lap
      for(const s of segs){
        const last = pts[pts.length-1];
        const Lcap = Math.min((s.frac||0)*scaleL, MAX_STRAIGHT_FRAC*targetLen);
        if(s.type==='straight'){
          const bias = centerBias();
          let L = Lcap;
          let tries=0; let cand;
          do{
            const dx = Math.cos(heading)*L + bias.x;
            const dy = Math.sin(heading)*L + bias.y;
            cand = {x:last.x+dx, y:last.y+dy};
            if(wouldSelfIntersect(pts, cand)) { heading += (r()-0.5)*0.6; L*=0.85; tries++; }
            else break;
          } while(tries<8);
          pts.push(cand); kinds.push('straight');
        } else {
          // Corner: single control point (exit), moderate length
          const turn = s.dTheta*(0.9+0.2*r());
          const L = Math.min((s.frac||0)*scaleL, 0.06*targetLen);
          const dx = Math.cos(heading+turn*0.6)*L;
          const dy = Math.sin(heading+turn*0.6)*L;
          let cand = {x:last.x+dx, y:last.y+dy};
          let tries=0; while(wouldSelfIntersect(pts, cand) && tries<8){ heading += (r()-0.5)*0.5; cand = {x:last.x+Math.cos(heading+turn*0.6)*L, y:last.y+Math.sin(heading+turn*0.6)*L}; tries++; }
          pts.push(cand); kinds.push('corner');
          heading += turn;
        }
      }
      // Close loop by connecting back towards origin
      const end = pts[pts.length-1];
      const toStart = Math.atan2(-end.y, -end.x);
      heading = heading*0.5 + toStart*0.5; // blend heading toward start
      let backL = Math.min(0.08*targetLen, 0.8 * (Math.hypot(end.x,end.y) || 1));
      let closeCand = {x:end.x + Math.cos(heading)*backL, y:end.y + Math.sin(heading)*backL};
      let tries=0; while(wouldSelfIntersect(pts, closeCand) && tries<10){ heading += (r()-0.5)*0.8; backL*=0.85; closeCand={x:end.x + Math.cos(heading)*backL, y:end.y + Math.sin(heading)*backL}; tries++; }
      pts.push(closeCand); kinds.push('straight');

      // Normalize: center and gentle rescale toward target length
      function lengthOf(a){ let L=0; for(let i=1;i<a.length;i++){ L+=Math.hypot(a[i].x-a[i-1].x, a[i].y-a[i-1].y); } return L; }
      const Lcur = lengthOf(pts);
      const sNorm = (targetLen / Math.max(1, Lcur));
      let minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9; for(const p of pts){ p.x*=sNorm; p.y*=sNorm; if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; }
      const cx=(minX+maxX)/2, cy=(minY+maxY)/2; for(const p of pts){ p.x-=cx; p.y-=cy; }

      // Convert to control points array with modest per-point tension (fewer points per corner)
      /** @type {{x:number,y:number,t:number,w:number,b:number}[]} */
      const out=[];
      for(let i=0;i<pts.length;i++){
        const p=pts[i];
        // Emphasize actual corners: set higher tension at corner points, low/negative at straights
        let t;
        if(kinds[i]==='corner'){
          t = 0.65 + 0.25*r(); // sharper corner influence
        } else {
          t = -0.45 + 0.25*r(); // smoother through straights
        }
        t = clamp(t, -1, 0.9);
        out.push({x:p.x, y:p.y, t, w: parseFloat(UI.globalWidth.value)||12, b: 0});
      }
      return out;
    }

    // Count self-intersections on the smoothed centerline (skip adjacent segments)
    function countSelfIntersectionsSmoothed(){
      const pts = smoothCache.pts || []; const closed = !!UI.closed.checked; const n = pts.length; if(n < 4) return 0;
      let cnt = 0;
      for(let i=0;i<n-1;i++){
        const a=pts[i], b=pts[i+1];
        for(let j=i+2;j<n-1;j++){
          // skip if segments share an endpoint (adjacent) or are the wrap pair in closed loop
          if(closed && i===0 && j===n-2) continue;
          if(segsIntersect(a,b, pts[j], pts[j+1])) cnt++;
        }
      }
      if(closed){
        const a=pts[n-1], b=pts[0];
        for(let j=1;j<n-2;j++){
          if(segsIntersect(a,b, pts[j], pts[j+1])) cnt++;
        }
      }
      return cnt;
    }

    function evaluateFlowAndVariety(){
      recompute(); const res = computeAnalysis(); const segs=res.segments;
      const total = segs.reduce((a,s)=>a+s.len,0)||1; let count={slow:0,medium:0,high:0};
      let corners=0; let flips=0; let prevSign=0; const pts=smoothCache.pts;
      function segTurnSign(s){ let sum=0; for(let i=s.start;i<Math.min(s.end, pts.length-1);i++){ const a=pts[i], b=pts[i+1]; const dx=b.x-a.x, dy=b.y-a.y; const dl=Math.hypot(dx,dy)||1; sum += (curvaturePerUnit(i)||0)*dl; } return Math.sign(sum||0); }
      for(const s of segs){ if(s.type==='corner'){ corners++; count[s.subtype] = (count[s.subtype]||0)+1; const sign=segTurnSign(s); if(prevSign!==0 && sign!==0 && sign!==prevSign) flips++; if(sign!==0) prevSign=sign; } }
      const varietyOK = (count.slow>0 && count.medium>0 && count.high>0);
      const zigzagRatio = corners? flips/corners : 0;
      const flowGood = zigzagRatio <= 0.35; // heuristic threshold
      return {varietyOK, flowGood, count, corners, zigzagRatio};
    }

    function runGenerate(seed){
      const km = Math.max(2.5, Math.min(50, parseFloat(document.getElementById('lapKm').value)||5.3));
      const style = (genStyleSel && genStyleSel.value) || 'balanced';
      const disc = (document.getElementById('discipline')?.value) || 'F1';
      let best=null; let bestScore=-1; let usedSeed=seed;
      for(let attempt=0; attempt<12; attempt++){
        const curSeed = (seed!=null)? seed : (Date.now()+attempt*1337)>>>0;
        const cand = generateTrack({km, style, discipline:disc, seed:curSeed});
        // mutate active layout points
        layouts[activeLayoutIndex].points.length = 0;
        Array.prototype.push.apply(layouts[activeLayoutIndex].points, cand);
        points = layouts[activeLayoutIndex].points; UI.closed.checked = true; selected=-1;
        const evalr = evaluateFlowAndVariety();
        // Penalize if any very long straight remains (analysis-based)
        const res = computeAnalysis();
        const total = res.segments.reduce((a,s)=>a+s.len,0)||1;
        const maxStraight = res.segments.filter(s=>s.type==='straight').reduce((m,s)=>Math.max(m,s.len),0);
        const longPenalty = (maxStraight/total > 0.10) ? 0.5 : 0;
        // Intersection penalty from smoothed polyline
        recompute();
        const inters = countSelfIntersectionsSmoothed();
        const interPenalty = inters>0 ? (1.5 + 0.5*inters) : 0;
        const score = (evalr.varietyOK?1:0) + (evalr.flowGood?1:0) - (evalr.zigzagRatio) - longPenalty - interPenalty;
        if(score>bestScore){ bestScore=score; best=cand; usedSeed=curSeed; }
        if(evalr.varietyOK && evalr.flowGood && longPenalty===0 && inters===0) break;
      }
      if(best){ layouts[activeLayoutIndex].points.length = 0; Array.prototype.push.apply(layouts[activeLayoutIndex].points, best); points = layouts[activeLayoutIndex].points; }
      selected=-1; syncSelectedUI(); recompute(); fitToScreen(); draw();
      return usedSeed;
    }

    // Spline (per-point tension)
    function catmullRomPV(p0,p1,p2,p3,t,s1,s2){ const tt=t*t, ttt=tt*t; const m1={x:(p2.x-p0.x)*s1, y:(p2.y-p0.y)*s1}; const m2={x:(p3.x-p1.x)*s2, y:(p3.y-p1.y)*s2}; const h00=2*ttt-3*tt+1, h10=ttt-2*tt+t, h01=-2*ttt+3*tt, h11=ttt-tt; return { x:h00*p1.x + h10*m1.x + h01*p2.x + h11*m2.x, y:h00*p1.y + h10*m1.y + h01*p2.y + h11*m2.y } }
    function sampleSplineWithMap(ctrl, closed, resolution){
      const n = ctrl.length;
      if (n < 2) {
        return {
          pts: ctrl.map(p => ({x:p.x, y:p.y})),
          segOf: ctrl.map((_, i) => i),
          tInSeg: ctrl.map(() => 0),
        };
      }
      const out = [], segOf = [], tInSeg = [];
      const get = i => ctrl[(i+n)%n];
      const res = Math.max(2, Math.floor(resolution));
      const eff = (p)=>({ t: +(p.t||0), tb: Math.max(-1, Math.min(1, +(p.tb||0))) });
      const base = (t)=> 0.5 * (1 - t);
      const sOut = (p)=> base(eff(p).t) * (1 + eff(p).tb);
      const sIn  = (p)=> base(eff(p).t) * (1 - eff(p).tb);

      if (!closed) {
        const ext = [ctrl[0], ...ctrl, ctrl[n-1]];
        for (let i = 0; i < ext.length-3; i++) {
          const P0=ext[i], P1=ext[i+1], P2=ext[i+2], P3=ext[i+3];
          const s1=sOut(P1), s2=sIn(P2);
          for (let k=0;k<res;k++){
            const t = k/res;
            out.push(catmullRomPV(P0,P1,P2,P3,t,s1,s2));
            segOf.push(i);
            tInSeg.push(t);
          }
        }
        out.push({x:ctrl[n-1].x,y:ctrl[n-1].y});
        segOf.push(n-2);
        tInSeg.push(1);
      } else {
        for (let i=0;i<n;i++){
          const P0=get(i-1), P1=get(i), P2=get(i+1), P3=get(i+2);
          const s1=sOut(P1), s2=sIn(P2);
          for (let k=0;k<res;k++){
            const t = k/res;
            out.push(catmullRomPV(P0,P1,P2,P3,t,s1,s2));
            segOf.push(i);
            tInSeg.push(t);
          }
        }
      }
      return { pts: out, segOf, tInSeg };
    }

    // Input handling
    let panning=false; let lastMouse={x:0,y:0};
    canvas.addEventListener('contextmenu', e=>e.preventDefault());
    // Helper: sample polyline for vector nodes (low-res for picking)
    function sampleVectorPolyline(nodes, closed, resolution){
      const n=nodes.length; if(n<2) return nodes.slice(); const infos=new Array(n); for(let i=0;i<n;i++) infos[i]=computeCornerInfoFor(nodes, closed, i);
      const out=[]; const start=infos[0]; const startP=(start&&start.valid)? start.T1 : {x:nodes[0].x,y:nodes[0].y}; out.push(startP);
      const segRes=Math.max(2, Math.floor((+resolution||300)/80));
      for(let i=0;i<n;i++){
        const inf=infos[i];
        if(inf && inf.valid){ let a1=inf.a1, a2=inf.a2; if(inf.ccw){ while(a2>a1) a2-=Math.PI*2; } else { while(a2<a1) a2+=Math.PI*2; }
          const delta=a2-a1; const steps=Math.max(2, Math.min(48, Math.floor(Math.abs(delta)/(Math.PI/segRes))+1));
          for(let k=1;k<=steps;k++){ const ang=a1 + delta*(k/steps); out.push({x:inf.center.x + Math.cos(ang)*inf.r, y:inf.center.y + Math.sin(ang)*inf.r}); }
        } else { out.push({x:nodes[i].x, y:nodes[i].y}); }
        const next=infos[(i+1)%n]; const hasNext=closed? true : (i+1<n); if(!hasNext) break; const nextP=(next&&next.valid)? next.T1 : {x:nodes[(i+1)%n].x, y:nodes[(i+1)%n].y}; out.push(nextP);
      }
      return out;
    }
    function nearestOnPolyline(pts, p){ let bestD=1e9, best=null, tBest=0, segIdx=-1; for(let i=0;i<pts.length-1;i++){ const a=pts[i], b=pts[i+1]; const abx=b.x-a.x, aby=b.y-a.y; const denom=abx*abx+aby*aby||1; const t=Math.max(0,Math.min(1,((p.x-a.x)*abx+(p.y-a.y)*aby)/denom)); const q={x:a.x+abx*t,y:a.y+aby*t}; const d=Math.hypot(p.x-q.x,p.y-q.y); if(d<bestD){ bestD=d; best=q; tBest=t; segIdx=i; } } return {q:best, t:tBest, i:segIdx}; }

    canvas.addEventListener('mousedown', (e)=>{
      const world=getMouseWorld(e); const right=e.button===2; const space=keys[' ']||keys['Spacebar'];
      // Start/Finish placement by track click (left click)
      if(sfPlaceArmed && e.button===0 && mode==='vector'){
        sfPlaceArmed=false;
        if(vNodes.length>=2){
          const poly = sampleVectorPolyline(vNodes, vectorClosed, parseInt(UI.resolution.value,10));
          if(poly.length>=2){ const hit=nearestOnPolyline(poly, world); const a=poly[hit.i], b=poly[hit.i+1]||a; let tx=b.x-a.x, ty=b.y-a.y; const L=Math.hypot(tx,ty)||1; tx/=L; ty/=L; startFinishTrack={x:hit.q.x, y:hit.q.y, tx, ty}; startFinishVNode=-1; draw(); }
        }
        return;
      }
      if(previewMode && !previewEditMode){ if(!right){ // allow left-drag panning in preview
          panning=true; lastMouse={x:e.clientX,y:e.clientY};
        } return; }
      if(previewMode && previewEditMode){ // allow left-drag panning; right-click edits
        if(!right){ panning=true; lastMouse={x:e.clientX,y:e.clientY}; return; }
      }
      if(space){ panning=true; lastMouse={x:e.clientX,y:e.clientY}; return }
      if(!right) return;
      
      // Save state before making changes
      saveToHistory();
      // Pit edit branch
      if(pitEditMode){
        // Pit vector editing
        // Check handle first if selected and handles shown
        if (UI.showCornerHandles && UI.showCornerHandles.checked && pitVSelected>=0){
          const info = computeCornerInfoFor(pitVNodes, pitVectorClosed, pitVSelected); if(info && info.bisector){
            const B=pitVNodes[pitVSelected]; const handle={x:B.x+info.bisector.x*(pitVNodes[pitVSelected].r||0), y:B.y+info.bisector.y*(pitVNodes[pitVSelected].r||0)}; const hs=worldToScreen(handle); const dx=e.clientX-hs.x, dy=e.clientY-hs.y; if(Math.hypot(dx,dy)<12){ pitDragging=true; pitDraggingIndex=-1; // flag handle drag via special state
              draggingVHandle=true; draggingVNode=pitVSelected; return; }
          }
        }
        const idx = pitHitTestVNode(world,10);
        if(idx>=0){ pitDraggingIndex=idx; pitDragging=true; pitVSelected=idx; syncSelectedPitVectorUI(); draw(); return; }
        const worldTol = 12/view.z;
        if(e.shiftKey){ const near=pitNearestVectorSegment(world); if(near.idx>=0 && near.d<worldTol){ const insIdx=near.idx+1; pitVNodes.splice(insIdx,0,{x:world.x,y:world.y,type:'sharp',r:0}); pitVSelected=insIdx; syncSelectedPitVectorUI(); draw(); return } }
        // append
        pitVNodes.push({x:world.x,y:world.y,type:'sharp',r:0}); pitVSelected=pitVNodes.length-1; syncSelectedPitVectorUI(); draw(); return;
      }

      if(mode==='vector'){
        // Vector editing
        // Check handle first if selected and handles shown
        if (UI.showCornerHandles && UI.showCornerHandles.checked && vSelected>=0){
          const hd = getVectorHandle(vSelected);
          if(hd){
            const hs = worldToScreen(hd);
            const dx = e.clientX - hs.x, dy = e.clientY - hs.y;
            if(Math.hypot(dx,dy) < 12){
              draggingVHandle = true; draggingVNode = vSelected; return;
            }
          }
        }
        const idx=hitTestVNode(world,10);
        if(idx>=0){ isDraggingVNode=true; draggingVNode=idx; vSelected=idx; syncSelectedVectorUI(); draw(); return; }
        const worldTol = 12/view.z;
        if(e.shiftKey){ const near=nearestVectorSegment(world); if(near.idx>=0 && near.d<worldTol){ const insIdx=near.idx+1; vNodes.splice(insIdx,0,{x:near.q.x,y:near.q.y,type:'sharp',r:0}); vSelected=insIdx; syncSelectedVectorUI(); draw(); return } }
        // Default: insert after selected if any; otherwise append
        const p=snapIf(world);
        if(vSelected>=0 && vNodes.length>0){
          const insIdx = vectorClosed ? ((vSelected+1) % Math.max(1, vNodes.length)) : Math.min(vSelected+1, vNodes.length);
          vNodes.splice(insIdx,0,{x:p.x,y:p.y,type:'sharp',r:0}); vSelected=insIdx; syncSelectedVectorUI(); draw(); return;
        }
        vNodes.push({x:p.x,y:p.y,type:'sharp',r:0}); vSelected=vNodes.length-1; syncSelectedVectorUI(); draw(); return;
      }

      if(mode==='add'){
        if(UI.closed.checked){ const nearC=nearestSmoothed(world); const pxTol=12, worldTol=pxTol/view.z; if(nearC.d<worldTol && nearC.seg>=0){ const insIdx=(nearC.seg+1)%points.length; points.splice(insIdx,0,{...snapIf(nearC.q), t:parseFloat(UI.tension.value)||0, w:getDefaultWidth(), b:getDefaultBank()}); selected=insIdx; syncSelectedUI(); recompute(); draw(); return } }
        if(e.shiftKey){ const near=nearestControlSegment(world); if(near.idx>=0 && near.d<14/view.z){ points.splice(near.idx+1,0,{...snapIf(near.q), t:parseFloat(UI.tension.value)||0, tb:0, w:getDefaultWidth(), b:getDefaultBank(), c:false}); selected=near.idx+1; syncSelectedUI(); recompute(); draw(); return } }
        points.push({...snapIf(world), t:parseFloat(UI.tension.value)||0, tb:0, w:getDefaultWidth(), b:getDefaultBank(), c:false}); selected=points.length-1; syncSelectedUI(); recompute(); draw(); return;
      }
      // edit
      const idx=hitTestPoint(world,10); if(idx>=0){ draggingIndex=idx; isDragging=true; selected=idx; syncSelectedUI(); }
    });
    canvas.addEventListener('mousemove', (e)=>{
      if(panning){ const dx=(e.clientX-lastMouse.x)/view.z, dy=(e.clientY-lastMouse.y)/view.z; view.x+=dx; view.y+=dy; lastMouse={x:e.clientX,y:e.clientY}; draw(); return }
      if(previewMode && !previewEditMode) return;
      const world=getMouseWorld(e);
      if(pitEditMode){
        // Handle drag to adjust radius
        if(draggingVHandle && pitVSelected>=0){
          const i=pitVSelected; const info = computeCornerInfoFor(pitVNodes, pitVectorClosed, i);
          if(info){ const B=pitVNodes[i]; const v={x:world.x-B.x,y:world.y-B.y}; const proj=v.x*(info.bisector?.x||0) + v.y*(info.bisector?.y||0); let desired=Math.max(0, proj); const clamped=clampRadiusForNodeIn(pitVNodes, i, desired); pitVNodes[i].type='round'; pitVNodes[i].r=clamped; draw(); }
          return;
        }
        if(!pitDragging) return; if(pitDraggingIndex>=0){ pitVNodes[pitDraggingIndex].x=world.x; pitVNodes[pitDraggingIndex].y=world.y; draw(); }
        return;
      }
      if(mode==='vector'){
        if(draggingVHandle && draggingVNode>=0){
          const i=draggingVNode; const info = computeCornerInfo(i);
          if(info && info.valid){
            const B = vNodes[i];
            const bis = info.bisector;
            const v = {x:world.x-B.x, y:world.y-B.y};
            const proj = v.x*bis.x + v.y*bis.y; // signed distance along bisector
            let newR = Math.max(0, proj);
            const clamped = clampRadiusForNode(i, newR);
            const delta = clamped - (vNodes[i].r||0);
            vNodes[i].type = 'round';
            vNodes[i].r = clamped;
            if(keys['Alt'] || keys['AltGraph'] || keys['Meta'] || e.altKey){
              const n=vNodes.length; const ip=(i-1+n)%n, inx=(i+1)%n;
              vNodes[ip].r = clampRadiusForNode(ip, Math.max(0,(vNodes[ip].r||0)+delta));
              vNodes[inx].r = clampRadiusForNode(inx, Math.max(0,(vNodes[inx].r||0)+delta));
            }
            syncSelectedVectorUI(false);
            draw();
          }
          return;
        }
        if(isDraggingVNode && draggingVNode>=0){ const p=snapIf(world); vNodes[draggingVNode].x=p.x; vNodes[draggingVNode].y=p.y; syncSelectedVectorUI(false); draw(); }
        return;
      }
      if(!isDragging) return; if(draggingIndex>=0){ const p=snapIf(world); points[draggingIndex].x=p.x; points[draggingIndex].y=p.y; syncSelectedUI(false); recompute(); draw(); }
    });
    window.addEventListener('mouseup', (e)=>{ if(panning){ panning=false; return } if(isDragging && e.button===2){ isDragging=false; draggingIndex=-1; } if(pitDragging && e.button===2){ pitDragging=false; pitDraggingIndex=-1; } if(mode==='vector'){ if(isDraggingVNode && e.button===2){ isDraggingVNode=false; draggingVNode=-1; } if(draggingVHandle && e.button===2){ draggingVHandle=false; draggingVNode=-1; } } });

    const keys={};
    window.addEventListener('keydown', e=>{
      // vector-only: ignore 'M' mode toggle
      if(e.key==='p'||e.key==='P') togglePreview(); 
      if(previewMode && e.key==='Escape') togglePreview(false); 
      if((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) { e.preventDefault(); undo(); }
      if((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) { e.preventDefault(); redo(); }
      keys[e.key]=true; 
      if(e.key==='Delete' && (!previewMode || previewEditMode)){
        saveToHistory();
        if(mode==='vector' && vSelected>=0){ vNodes.splice(vSelected,1); vSelected=-1; syncSelectedVectorUI(); draw(); }
        else if(pitEditMode && pitVSelected>=0){ pitVNodes.splice(pitVSelected,1); pitVSelected=-1; draw(); }
        else if(selected>=0){ points.splice(selected,1); selected=-1; syncSelectedUI(); recompute(); draw(); }
      }
    });
    window.addEventListener('keyup', e=>{ keys[e.key]=false });

    // Buttons / sliders
    function syncBadges(){
      if(UI.valResolution && UI.resolution) UI.valResolution.textContent = UI.resolution.value;
      if(UI.valGlobalWidth && UI.globalWidth) UI.valGlobalWidth.textContent = (+UI.globalWidth.value).toFixed(1);
      if(UI.valGlobalBank && UI.globalBank) UI.valGlobalBank.textContent = (+UI.globalBank.value).toFixed(1)+'¬∞';
      if(UI.valAutoStrength && UI.autoStrength) UI.valAutoStrength.textContent = (+UI.autoStrength.value).toString();
      if(UI.valAutoMax && UI.autoMax) UI.valAutoMax.textContent = (+UI.autoMax.value)+'¬∞';
      if(UI.valPitWidth && UI.pitWidth) UI.valPitWidth.textContent = (+UI.pitWidth.value).toFixed(1);
      if(UI.valVectorInflate && UI.vectorInflate) UI.valVectorInflate.textContent = (+UI.vectorInflate.value).toFixed(1);
      if(selected>=0){
        if(UI.valPWidth && UI.pwidth) UI.valPWidth.textContent = (+UI.pwidth.value).toFixed(1);
        if(UI.valPBank && UI.pbank) UI.valPBank.textContent = (+UI.pbank.value).toFixed(1)+'¬∞';
        if(UI.valTBias && UI.tbias) UI.valTBias.textContent = (+(UI.tbias?.value||0)).toFixed(2);
      }
    }
    if(UI.tension) UI.tension.addEventListener('input', syncBadges);
    if(UI.tbias) UI.tbias.addEventListener('input', ()=>{ UI.valTBias.textContent=(+UI.tbias.value).toFixed(2); if(selected>=0){ points[selected].tb=+UI.tbias.value; recompute(); draw(); } });
    UI.resolution.addEventListener('input', ()=>{ syncBadges(); recompute(); draw(); });
    UI.closed.addEventListener('change', ()=>{ recompute(); draw(); });
    UI.snap.addEventListener('change', draw);
    UI.grid.addEventListener('input', ()=>{ if(UI.snap.checked) draw() });
    UI.showCtrl.addEventListener('change', draw);
    UI.clear.addEventListener('click', ()=>{ saveToHistory(); if(pitEditMode){ pitVNodes=[]; pitVSelected=-1; draw(); } else if(mode==='vector'){ vNodes.length=0; vSelected=-1; syncSelectedVectorUI(); draw(); } else { layouts[activeLayoutIndex].points.length = 0; points = layouts[activeLayoutIndex].points; selected=-1; syncSelectedUI(); recompute(); draw(); } });
    UI.fit.addEventListener('click', fitToScreen);
    UI.globalWidth.addEventListener('input', ()=>{ syncBadges(); draw(); });
    UI.usePerWidth.addEventListener('change', ()=>{ recompute(); draw(); });
    if(UI.pitWidth) UI.pitWidth.addEventListener('input', ()=>{ syncBadges(); draw(); });
    if(UI.pitEnabled) UI.pitEnabled.addEventListener('change', ()=>{ draw(); });
    UI.globalBank.addEventListener('input', ()=>{ syncBadges(); draw(); });
    UI.usePerBank.addEventListener('change', ()=>{ draw(); });
    UI.autoBank.addEventListener('change', ()=>{ draw(); });
    UI.autoStrength.addEventListener('input', ()=>{ syncBadges(); draw(); });
    UI.autoMax.addEventListener('input', ()=>{ syncBadges(); draw(); });
    UI.smoothBank.addEventListener('change', ()=>{ draw(); });
    UI.showBankViz.addEventListener('change', ()=>{ draw(); });
    // Layouts
    if(UI.layoutSelect){ UI.layoutSelect.addEventListener('change', (e)=>{ const idx=parseInt(UI.layoutSelect.value,10)||0; saveToHistory(); setActiveLayout(idx); }); }
    if(UI.layoutNew){ UI.layoutNew.addEventListener('click', ()=>{ saveToHistory(); newLayout(); }); }
    if(UI.layoutClone){ UI.layoutClone.addEventListener('click', ()=>{ saveToHistory(); cloneActiveLayout(); }); }
    if(UI.layoutRename){ UI.layoutRename.addEventListener('click', ()=>{ const cur=layouts[activeLayoutIndex]; const name=prompt('Rename layout:', cur.name||''); if(name!=null){ saveToHistory(); renameActiveLayout(name.trim()||cur.name); } }); }
    if(UI.layoutDelete){ UI.layoutDelete.addEventListener('click', ()=>{ if(layouts.length<=1) return; if(confirm('Delete this layout?')){ saveToHistory(); deleteActiveLayout(); } }); }
    if(UI.showAltOverlays){ UI.showAltOverlays.addEventListener('change', ()=>{ draw(); }); }

    // Undo/Redo/Import/Export buttons
    UI.undoBtn.addEventListener('click', undo);
    UI.redoBtn.addEventListener('click', redo);
    UI.importBtn.addEventListener('click', () => fileInput.click());
    UI.exportBtn.addEventListener('click', exportTrack);
    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        importTrack(e.target.files[0]);
        e.target.value = ''; // Reset file input
      }
    });

    UI.applyXY.addEventListener('click', ()=>{ if(mode==='vector'){ if(vSelected<0) return; saveToHistory(); const nx=parseFloat(UI.px.value)||0, ny=parseFloat(UI.py.value)||0; vNodes[vSelected].x=nx; vNodes[vSelected].y=ny; draw(); } else { if(selected<0) return; saveToHistory(); const nx=parseFloat(UI.px.value)||0, ny=parseFloat(UI.py.value)||0; points[selected].x=nx; points[selected].y=ny; recompute(); draw(); }});
    if(UI.ptension) UI.ptension.addEventListener('input', ()=>{ if(selected<0) return; const min=parseFloat(UI.ptension.min)||-2, max=parseFloat(UI.ptension.max)||1; const raw=parseFloat(UI.ptension.value)||0; const t=Math.max(min, Math.min(max, raw)); points[selected].t=t; if(UI.valPTension) UI.valPTension.textContent=t.toFixed(2); recompute(); draw(); });
    if(UI.isCorner) UI.isCorner.addEventListener('change', ()=>{ if(selected<0) return; points[selected].c=!!UI.isCorner.checked; draw(); });
    if(UI.pwidth) UI.pwidth.addEventListener('input', ()=>{ if(selected<0) return; const w=Math.max(0.1, parseFloat(UI.pwidth.value)||getDefaultWidth()); points[selected].w=w; if(UI.valPWidth) UI.valPWidth.textContent=w.toFixed(1); if(UI.usePerWidth && !UI.usePerWidth.checked){ UI.usePerWidth.checked = true; } recompute(); draw(); });
    if(UI.pbank) UI.pbank.addEventListener('input', ()=>{ if(selected<0) return; const b=parseFloat(UI.pbank.value)||0; points[selected].b=b; if(UI.valPBank) UI.valPBank.textContent=b.toFixed(1)+'¬∞'; if(UI.usePerBank && !UI.usePerBank.checked){ UI.usePerBank.checked = true; } draw(); });
    UI.deletePoint.addEventListener('click', ()=>{ if(mode==='vector'){ if(vSelected<0) return; saveToHistory(); vNodes.splice(vSelected,1); vSelected=-1; syncSelectedVectorUI(); draw(); } else { if(selected<0) return; saveToHistory(); points.splice(selected,1); selected=-1; syncSelectedUI(); recompute(); draw(); }});

    // Tests
    UI.testHairpin.addEventListener('click', ()=>{ saveToHistory(); loadHairpinTest(); });
    UI.testChicane.addEventListener('click', ()=>{ saveToHistory(); loadChicaneTest(); });

    // AI Generate buttons
    genBtn.addEventListener('click', ()=>{ saveToHistory(); const seed = runGenerate(); /* could display seed if needed */ });
    regenBtn.addEventListener('click', ()=>{ saveToHistory(); runGenerate(); });

    // Vector wiring
    if(UI.vectorFromTrack) UI.vectorFromTrack.addEventListener('change', ()=>{ if(UI.vectorFromTrack.checked && mode==='vector'){ saveToHistory(); buildOutlineFromCenterline(); draw(); } });
    if(UI.vectorInflate) UI.vectorInflate.addEventListener('input', ()=>{ if(layouts[activeLayoutIndex]?.vector){ layouts[activeLayoutIndex].vector.inflate = (parseFloat(UI.vectorInflate.value)||0); } syncBadges(); if(UI.vectorFromTrack && UI.vectorFromTrack.checked && mode==='vector'){ buildOutlineFromCenterline(); } draw(); });
    if(UI.showCornerHandles) UI.showCornerHandles.addEventListener('change', ()=>{ draw(); });
    if(UI.vectorBuildNow) UI.vectorBuildNow.addEventListener('click', ()=>{ saveToHistory(); buildOutlineFromCenterline(); draw(); });
    if(UI.vradius) UI.vradius.addEventListener('input', ()=>{
      const val = Math.max(0, parseFloat(UI.vradius.value)||0);
      if(pitEditMode && pitVSelected>=0){ pitVNodes[pitVSelected].r = clampRadiusForNodeIn(pitVNodes, pitVSelected, val); if(pitVNodes[pitVSelected].type==='sharp' && pitVNodes[pitVSelected].r>0) pitVNodes[pitVSelected].type='round'; syncSelectedPitVectorUI(false); draw(); return; }
      if(vSelected<0) return; vNodes[vSelected].r = clampRadiusForNode(vSelected, val); if(vNodes[vSelected].type==='sharp' && vNodes[vSelected].r>0) vNodes[vSelected].type='round'; syncSelectedVectorUI(false); draw();
    });
    if(UI.vtype) UI.vtype.addEventListener('change', ()=>{
      const t = UI.vtype.value==='round'?'round':'sharp';
      if(pitEditMode && pitVSelected>=0){ pitVNodes[pitVSelected].type=t; if(t==='round' && (pitVNodes[pitVSelected].r||0)<=0){ pitVNodes[pitVSelected].r=4; } if(t==='sharp'){ pitVNodes[pitVSelected].r=0; } syncSelectedPitVectorUI(false); draw(); return; }
      if(vSelected<0) return; vNodes[vSelected].type=t; if(t==='round' && (vNodes[vSelected].r||0)<=0){ vNodes[vSelected].r=4; } if(t==='sharp'){ vNodes[vSelected].r=0; } syncSelectedVectorUI(false); draw();
    });
    if(UI.insertMid) UI.insertMid.addEventListener('click', ()=>{ if(vSelected<0) return; const i=vSelected; const n=vNodes.length; if(n===0) return; let j=i+1; if(j>=n){ if(!vectorClosed) return; j=0; }
      saveToHistory();
      const A=vNodes[i], B=vNodes[j];
      const p={x:(A.x+B.x)/2, y:(A.y+B.y)/2};
      vNodes.splice(i+1,0,{x:p.x,y:p.y,type:'sharp',r:0});
      vSelected = i+1; syncSelectedVectorUI(); draw();
    });

    function updateMiniVisibility(){
      // Only show mini editor in Preview Edit (not plain Preview)
      mini.panel.classList.toggle('hidden', !previewEditMode);
    }
    function togglePreview(force){
      const entering=(typeof force==='boolean')? (force===true):!previewMode;
      previewMode=(typeof force==='boolean')? force : !previewMode;
      if(!previewMode) previewEditMode=false;
      wrap.classList.toggle('preview-mode', previewMode);
      wrap.classList.toggle('preview-edit', previewEditMode);
      topbar.classList.toggle('hidden', previewMode);
      sidebar.classList.toggle('hidden', previewMode);
      hud.classList.toggle('hidden', previewMode);
      exitPreviewBtn.classList.toggle('hidden', !previewMode);
      updateMiniVisibility();
      if(entering){
        requestAnimationFrame(()=>{
          doResize();
          if(!UI.fitOnPreview || UI.fitOnPreview.checked) fitToScreen();
        });
      } else {
        requestAnimationFrame(doResize)
      }
      draw();
    }
    function togglePreviewEdit(force){
      const to=(typeof force==='boolean')? force : !previewEditMode;
      previewEditMode=to;
      if(to && !previewMode) previewMode=true;
      wrap.classList.toggle('preview-mode', previewMode);
      wrap.classList.toggle('preview-edit', previewEditMode);
      topbar.classList.toggle('hidden', previewMode);
      sidebar.classList.toggle('hidden', previewMode);
      hud.classList.toggle('hidden', previewMode);
      exitPreviewBtn.classList.toggle('hidden', !previewMode);
      updateMiniVisibility();
      requestAnimationFrame(()=>{
        doResize();
        if(!UI.fitOnPreview || UI.fitOnPreview.checked) fitToScreen();
      });
      draw();
    }
    function togglePitEdit(){ pitEditMode = !pitEditMode; pitEditBtn && pitEditBtn.classList.toggle('active', pitEditMode); draw(); }
    previewBtn.addEventListener('click', ()=>togglePreview()); exitPreviewBtn.addEventListener('click', ()=>togglePreview(false));
    if(pitEditBtn) pitEditBtn.addEventListener('click', ()=>togglePitEdit());
    // Analyze button
    analyzeBtn.addEventListener('click', ()=>{ analysisMode = !analysisMode; analyzeBtn.textContent = analysisMode ? 'Hide Analysis' : 'Analyze'; analysisCache = null; draw(); });

    // Info / Help overlay
    const infoBtn = document.getElementById('infoBtn');
    const helpOverlay = document.getElementById('helpOverlay');
    const helpClose = document.getElementById('helpClose');
    function showHelp(to=true){ helpOverlay.style.display = to? 'flex':'none'; }
    infoBtn.addEventListener('click', ()=>showHelp(true));
    helpClose.addEventListener('click', ()=>showHelp(false));
    helpOverlay.addEventListener('click', (e)=>{ if(e.target===helpOverlay) showHelp(false); });
    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && helpOverlay.style.display==='flex') showHelp(false); });

    // Suggestion button
    UI.suggestBtn.addEventListener('click', ()=>{ runSuggestions(); });

    // Start/Finish buttons
    const sfSetBtn = document.getElementById('sfSet');
    const sfClearBtn = document.getElementById('sfClear');
    if(sfSetBtn) sfSetBtn.addEventListener('click', ()=>{ if(vSelected>=0){ startFinishVNode = vSelected; startFinishTrack=null; draw(); } });
    if(sfClearBtn) sfClearBtn.addEventListener('click', ()=>{ startFinishVNode = -1; startFinishTrack=null; draw(); });
    const sfPlaceBtn = document.getElementById('sfPlace');
    if(sfPlaceBtn) sfPlaceBtn.addEventListener('click', ()=>{ sfPlaceArmed = true; hud.textContent = 'Click on track to place Start/Finish'; });

    // Selected point UI
    function syncMiniFromSelected(){ if(selected<0 || selected>=points.length){ mini.selIndex.textContent='‚Äî'; mini.px.value=0; mini.py.value=0; mini.ptension.value=0; mini.valPTension.textContent='0.00'; if(mini.tbias){ mini.tbias.value=0; mini.valTBias.textContent='0.00'; } if(mini.isCorner) mini.isCorner.checked=false; mini.pwidth.value=UI.globalWidth.value; mini.valPWidth.textContent=UI.globalWidth.value; mini.pbank.value=0; mini.valPBank.textContent='0.0¬∞'; return; } const p=points[selected]; mini.selIndex.textContent=String(selected); mini.px.value=Math.round(p.x); mini.py.value=Math.round(p.y); mini.ptension.value=(p.t||0).toFixed(2); mini.valPTension.textContent=(p.t||0).toFixed(2); if(mini.tbias){ const tb=+(p.tb||0); mini.tbias.value=tb.toFixed(2); mini.valTBias.textContent=tb.toFixed(2); } if(mini.isCorner) mini.isCorner.checked=!!p.c; const w=(p.w||getDefaultWidth()); mini.pwidth.value=w.toFixed(1); mini.valPWidth.textContent=w.toFixed(1); mini.pbank.value=(p.b||0).toFixed(1); mini.valPBank.textContent=(p.b||0).toFixed(1)+'¬∞'; }
    function syncSelectedUI(pushInputs=true){
      // Vector-only: if full point controls are missing, only sync X/Y and index
      if(!UI.px || !UI.py){ return; }
      if(selected<0 || selected>=points.length){
        UI.selIndex.textContent='‚Äî';
        UI.px.value=0; UI.py.value=0;
        UI.px.classList.add('readonly'); UI.py.classList.add('readonly');
        syncMiniFromSelected();
        return;
      }
      const p=points[selected];
      UI.selIndex.textContent=String(selected);
      if(pushInputs){ UI.px.value=Math.round(p.x); UI.py.value=Math.round(p.y); }
      UI.px.classList.remove('readonly'); UI.py.classList.remove('readonly');
      syncMiniFromSelected();
    }
    function syncSelectedVectorUI(pushInputs=true){
      const hasSel = !(vSelected<0 || vSelected>=vNodes.length);
      if(!hasSel){
        UI.selIndex.textContent='‚Äî';
        if(UI.px) UI.px.value=0; if(UI.py) UI.py.value=0;
        if(UI.vradius) UI.vradius.value=0; if(UI.vtype) UI.vtype.value='sharp';
        if(UI.px) UI.px.classList.add('readonly'); if(UI.py) UI.py.classList.add('readonly');
        if(UI.insertAfter) UI.insertAfter.disabled = true;
        if(UI.insertMid) UI.insertMid.disabled = true;
        return;
      }
      const p=vNodes[vSelected];
      UI.selIndex.textContent=String(vSelected);
      if(pushInputs){ if(UI.px) UI.px.value=Math.round(p.x); if(UI.py) UI.py.value=Math.round(p.y); if(UI.vradius) UI.vradius.value=(p.r||0).toFixed(1); if(UI.vtype) UI.vtype.value=p.type==='round'?'round':'sharp'; }
      if(UI.px) UI.px.classList.remove('readonly'); if(UI.py) UI.py.classList.remove('readonly');
      // Enable/disable insertion buttons depending on whether a 'next' exists
      const n=vNodes.length; const openTail = (!vectorClosed && vSelected===n-1);
      if(UI.insertAfter) UI.insertAfter.disabled = openTail;
      if(UI.insertMid) UI.insertMid.disabled = openTail || n<2;
    }
    function syncSelectedPitVectorUI(pushInputs=true){
      if(pitVSelected<0 || pitVSelected>=pitVNodes.length){
        UI.selIndex.textContent='‚Äî';
        if(UI.px) UI.px.value=0; if(UI.py) UI.py.value=0;
        if(UI.vradius) UI.vradius.value=0; if(UI.vtype) UI.vtype.value='sharp';
        if(UI.px) UI.px.classList.add('readonly'); if(UI.py) UI.py.classList.add('readonly');
        return;
      }
      const p=pitVNodes[pitVSelected];
      UI.selIndex.textContent=String(pitVSelected);
      if(pushInputs){ if(UI.px) UI.px.value=Math.round(p.x); if(UI.py) UI.py.value=Math.round(p.y); if(UI.vradius) UI.vradius.value=(p.r||0).toFixed(1); if(UI.vtype) UI.vtype.value=p.type==='round'?'round':'sharp'; }
      if(UI.px) UI.px.classList.remove('readonly'); if(UI.py) UI.py.classList.remove('readonly');
    }
    // Mini editor events
    mini.applyXY.addEventListener('click', ()=>{ if(selected<0) return; saveToHistory(); const nx=parseFloat(mini.px.value)||0, ny=parseFloat(mini.py.value)||0; points[selected].x=nx; points[selected].y=ny; UI.px.value=nx; UI.py.value=ny; recompute(); draw(); });
    mini.ptension.addEventListener('input', ()=>{ if(selected<0) return; const min=parseFloat(mini.ptension.min)||-2, max=parseFloat(mini.ptension.max)||1; const raw=parseFloat(mini.ptension.value)||0; const t=Math.max(min, Math.min(max, raw)); points[selected].t=t; mini.valPTension.textContent=t.toFixed(2); UI.ptension.value=t.toFixed(2); UI.valPTension.textContent=t.toFixed(2); recompute(); draw(); });
    if(mini.tbias) mini.tbias.addEventListener('input', ()=>{ if(selected<0) return; const tb = Math.max(-1, Math.min(1, +(mini.tbias.value)||0)); points[selected].tb=tb; mini.valTBias.textContent=tb.toFixed(2); if(UI.tbias){ UI.tbias.value=tb.toFixed(2); UI.valTBias.textContent=tb.toFixed(2); } recompute(); draw(); });
    if(mini.isCorner) mini.isCorner.addEventListener('change', ()=>{ if(selected<0) return; points[selected].c=!!mini.isCorner.checked; if(UI.isCorner) UI.isCorner.checked=mini.isCorner.checked; draw(); });
    mini.pwidth.addEventListener('input', ()=>{ if(selected<0) return; const w=Math.max(0.1, parseFloat(mini.pwidth.value)||getDefaultWidth()); points[selected].w=w; mini.valPWidth.textContent=w.toFixed(1); UI.pwidth.value=w.toFixed(1); UI.valPWidth.textContent=w.toFixed(1); if(!UI.usePerWidth.checked){ UI.usePerWidth.checked = true; } recompute(); draw(); });
    mini.pbank.addEventListener('input', ()=>{ if(selected<0) return; const b=parseFloat(mini.pbank.value)||0; points[selected].b=b; mini.valPBank.textContent=b.toFixed(1)+'¬∞'; UI.pbank.value=b.toFixed(1); UI.valPBank.textContent=b.toFixed(1)+'¬∞'; if(!UI.usePerBank.checked){ UI.usePerBank.checked = true; } draw(); });
    mini.deletePoint.addEventListener('click', ()=>{ if(selected<0) return; saveToHistory(); points.splice(selected,1); selected=-1; syncSelectedUI(); recompute(); draw(); });

    function getDefaultWidth(){ return parseFloat(UI.globalWidth.value)||12 }
    function getDefaultBank(){ return parseFloat(UI.globalBank.value)||0 }

    function fitToScreen(){
      if(points.length===0){ view.x=0; view.y=0; view.z=1; draw(); return }
      const res = parseInt(UI.resolution.value,10) || 300;
      const sm = sampleSplineWithMap(points, UI.closed.checked, res).pts;
      let minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9;
      const src = sm.length>1? sm : points;
      for(const p of src){ minX=Math.min(minX,p.x); minY=Math.min(minY,p.y); maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y); }
      const rect=canvas.getBoundingClientRect(); const pad=80;
      const sx=(rect.width-2*pad)/Math.max(1,maxX-minX);
      const sy=(rect.height-2*pad)/Math.max(1,maxY-minY);
      view.z=Math.max(0.1,Math.min(4,Math.min(sx,sy)));
      view.x=-(minX+maxX)/2; view.y=-(minY+maxY)/2;
      draw();
    }

    function curveLength(path){ let L=0; for(let i=1;i<path.length;i++){ const dx=path[i].x-path[i-1].x, dy=path[i].y-path[i-1].y; L+=Math.hypot(dx,dy) } return L }

    function recompute(){ smoothCache = sampleSplineWithMap(points, UI.closed.checked, parseInt(UI.resolution.value,10)); analysisCache = null; }

    // Width sampling per smoothed vertex
    function widthAtSample(index){
      if(!UI.usePerWidth.checked) return getDefaultWidth();
      const seg = smoothCache.segOf[index];
      if (seg == null || seg < 0 || points.length === 0) return getDefaultWidth();
      const i0 = seg, i1 = (seg + 1) % points.length;
      const w0 = points[i0]?.w ?? getDefaultWidth();
      const w1 = points[i1]?.w ?? getDefaultWidth();
      const t  = smoothCache.tInSeg[index] ?? 0; // true 0..1 within the segment
      return w0*(1-t) + w1*t;
    }

    // Curvature per unit length (rad per unit), signed by turn direction
    function curvaturePerUnit(i){
      const pts = smoothCache.pts;
      const n = pts.length;
      if(n < 3) return 0;
      const im = UI.closed.checked ? (i-1+n)%n : Math.max(0, i-1);
      const ip = UI.closed.checked ? (i+1)%n : Math.min(n-1, i+1);
      const a = pts[im], b = pts[i], c = pts[ip];
      let v1 = {x:b.x-a.x, y:b.y-a.y};
      let v2 = {x:c.x-b.x, y:c.y-b.y};
      const l1 = Math.hypot(v1.x, v1.y);
      const l2 = Math.hypot(v2.x, v2.y);
      if(l1 < 1e-6 || l2 < 1e-6) return 0;
      v1.x /= l1; v1.y /= l1; v2.x /= l2; v2.y /= l2;
      const dot = Math.max(-1, Math.min(1, v1.x*v2.x + v1.y*v2.y));
      const ang = Math.acos(dot); // radians, 0..pi
      const cross = v1.x*v2.y - v1.y*v2.x; // sign of turn
      const signed = ang * Math.sign(cross || 1);
      const avgLen = 0.5 * (l1 + l2);
      return signed / Math.max(1e-6, avgLen);
    }

    // Banking sampling per smoothed vertex (degrees)
    function bankAtSampleBase(index){
      let base = UI.usePerBank.checked ? (()=>{ const seg=smoothCache.segOf[index]; if(seg==null||seg<0||points.length===0) return getDefaultBank(); const i0=seg, i1=(seg+1)%points.length; const b0=(points[i0]?.b)||0, b1=(points[i1]?.b)||0; const t=smoothCache.tInSeg[index]||0; return b0*(1-t)+b1*t; })() : getDefaultBank();
      if(UI.autoBank.checked){ const k = curvaturePerUnit(index); const strength = parseFloat(UI.autoStrength.value) || 0; const auto = Math.max(-parseFloat(UI.autoMax.value), Math.min(parseFloat(UI.autoMax.value), k * strength)); base += auto; }
      return base; // degrees
    }

    function bankAtSample(index){
      if(UI.smoothBank && UI.smoothBank.checked){
        const pts = smoothCache.pts; const n = pts.length; if(n===0) return 0;
        const half = 2; let sum=0, count=0;
        for(let d=-half; d<=half; d++){
          let j = index + d;
          if(UI.closed.checked){ j = (j % n + n) % n; }
          else { if(j<0 || j>=n) continue; }
          sum += bankAtSampleBase(j); count++;
        }
        return sum / Math.max(1, count);
      }
      return bankAtSampleBase(index);
    }

    function buildOffsetPolygons(center){ if(center.length<2) return null; const left=[], right=[]; const n=center.length; for(let i=0;i<n;i++){ const p=center[i]; const pm=center[(i-1+n)%n]; const pp=center[(i+1)%n]; const tx=pp.x-pm.x, ty=pp.y-pm.y; const len=Math.hypot(tx,ty)||1; const nx=-ty/len, ny=tx/len; const w = widthAtSample(i); const hw = w*0.5; left.push({x:p.x+nx*hw, y:p.y+ny*hw}); right.push({x:p.x-nx*hw, y:p.y-ny*hw}); } return {left,right}; }

    function colorForBank(deg){ const d=Math.max(-20,Math.min(20,deg)); const t=(d+20)/40; // 0..1
      // blue (neg) -> white (0) -> red (pos)
      const r = Math.round(255 * t);
      const g = Math.round(255 * (0.9 - Math.abs(t-0.5))); // keep mid bright
      const b = Math.round(255 * (1 - t));
      return `rgb(${r},${g},${b})`;
    }

    // ===== Analysis: detect corners (slow/med/high) and straights (DRS?) =====
    function percentile(arr, p){ if(!arr.length) return 0; const s=arr.slice().sort((a,b)=>a-b); const idx=Math.min(s.length-1, Math.max(0, Math.floor((s.length-1)*p))); return s[idx]; }
    function classifyCorner(avgK, kHigh, kSlow){ if(avgK >= kSlow) return 'slow'; if(avgK >= kHigh) return 'medium'; return 'high'; }
    function computeAnalysis(){
      const pts = smoothCache.pts; const n = pts.length; if(n<3) return {segments:[], thresholds:{K95:0,kStraight:0,minDRS:0,Ltotal:0}};
      const absK = new Array(n).fill(0).map((_,i)=>Math.abs(curvaturePerUnit(i))||0);
      const validK = absK.filter(x=>isFinite(x));
      const K95 = percentile(validK, 0.95) || Math.max(...absK) || 0;
      const kStraight = Math.max(0.0015, 0.15 * K95);
      const Ltotal = curveLength(pts);
      const minDRS = Math.max(60, 0.05 * Ltotal);
      // Adaptive thresholds for corner classes
      const kCorner = validK.filter(k=>k >= kStraight);
      let kHigh = kStraight * 1.18; // widen "high" to catch very quick mediums
      let kSlow = K95 * 0.55;       // lower slow boundary so tighter mediums drop to slow
      if(kCorner.length >= 6){
        const p40 = percentile(kCorner, 0.40);
        const p70 = percentile(kCorner, 0.70);
        kHigh = Math.max(kHigh, p40);
        kSlow = Math.max(kHigh + 1e-6, p70);
      }
      const segments = [];
      let i=0;
      while(i < n-1){
        const isStraight = absK[i] < kStraight;
        const start=i; let len=0, kSum=0, ang=0; let j=i;
        while(j < n-1){
          const cond = (absK[j] < kStraight) === isStraight;
          if(!cond) break;
          const a=pts[j], b=pts[j+1];
          const dx=b.x-a.x, dy=b.y-a.y; const dl2=Math.hypot(dx,dy);
          len += dl2; kSum += absK[j]*dl2; ang += absK[j]*dl2; j++;
        }
        const avgK = len>0 ? kSum/len : 0;
        if(isStraight){ const subtype = (len >= minDRS) ? 'drs' : null; segments.push({type:'straight', start, end:j, len, avgK, ang, subtype}); }
        else { const subtype = classifyCorner(avgK, kHigh, kSlow); segments.push({type:'corner', start, end:j, len, avgK, ang, subtype}); }
        i=j;
      }
      if(UI.closed.checked && segments.length>1){
        const first=segments[0], last=segments[segments.length-1];
        if(first.type===last.type){
          // Include wrap segment distance (n-1 -> 0) so straights across seam are not undercounted
          const a = pts[n-1], b = pts[0]; const dWrap = Math.hypot(b.x-a.x, b.y-a.y);
          const mergedLen = last.len + first.len + dWrap;
          const mergedAng = last.ang + first.ang + (absK[n-1]||0)*dWrap;
          last.end = first.end; last.len = mergedLen; last.ang = mergedAng; last.avgK = mergedLen>0 ? mergedAng/mergedLen : 0;
          if(last.type==='corner') last.subtype = classifyCorner(last.avgK, kHigh, kSlow); else last.subtype = (last.len >= minDRS) ? 'drs' : null;
          segments.shift();
        }
      }
      return {segments, thresholds:{K95,kStraight,kHigh,kSlow,minDRS,Ltotal}};
    }

    // ===== Suggestions (Multi‚Äëdiscipline) =====
    function formatLapTime(seconds){ seconds = Math.max(1, seconds||0); const m=Math.floor(seconds/60); const s=seconds - m*60; return `${m}:${s.toFixed(1).padStart(4,'0')}`; }
    function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
    // Speed bands (km/h) and length norms per discipline
    const DISCIPLINES = {
      F1:      { label:'F1',      kind:'lap',   vSlow:90,  vMed:150, vHigh:210, vSt:300, vDRS:320, len:{short:3.5, long:7.0} },
      Hypercar:{ label:'Hypercar',kind:'lap',   vSlow:85,  vMed:140, vHigh:195, vSt:290, vDRS:null, len:{short:3.5, long:7.5} },
      GT3:     { label:'GT3',     kind:'lap',   vSlow:70,  vMed:120, vHigh:170, vSt:260, vDRS:null, len:{short:3.0, long:6.0} },
      Rally:   { label:'Rally',   kind:'stage', vSlow:60,  vMed:100, vHigh:140, vSt:160, vDRS:null, len:{short:4.0, long:25.0} }
    };
    function runSuggestions(){
      const res = analysisCache || computeAnalysis(); analysisCache = res;
      const segs = res.segments || [];
      if(segs.length===0){ UI.suggestBox.textContent = 'Add some points to get suggestions.'; return; }
      const total = segs.reduce((a,s)=>a+s.len,0) || 1;
      let Ls=0,Lm=0,Lh=0,Lst=0,Ldrs=0, corners=0;
      let longestStraight=0;
      for(const s of segs){
        if(s.type==='corner'){ corners++; if(s.subtype==='slow') Ls+=s.len; else if(s.subtype==='medium') Lm+=s.len; else Lh+=s.len; }
        else { Lst+=s.len; if(s.subtype==='drs') Ldrs+=s.len; if(s.len>longestStraight) longestStraight=s.len; }
      }
      const fs=Ls/total, fm=Lm/total, fh=Lh/total, fst=Lst/total, fdrs=Ldrs/total;
      const longestStraightPct = 100*longestStraight/total;

      // Time estimate from length (km) using class‚Äëspecific speeds (km/h)
      const discKey = (UI.discipline && UI.discipline.value) || 'F1';
      const D = DISCIPLINES[discKey] || DISCIPLINES.F1;
      const lapKm = clamp(parseFloat(UI.lapKm.value)||5.3, 2.0, 50.0);
      const Lmtrs = lapKm*1000;
      const tSlow = fs*Lmtrs/(D.vSlow/3.6);
      const tMed  = fm*Lmtrs/(D.vMed/3.6);
      const tHigh = fh*Lmtrs/(D.vHigh/3.6);
      let tStraight = 0;
      if(D.label==='F1' && D.vDRS){
        const tDRS  = fdrs*Lmtrs/(D.vDRS/3.6);
        const tRest = (Math.max(0,fst - fdrs))*Lmtrs/(D.vSt/3.6);
        tStraight = tDRS + tRest; // Only F1 considers DRS separately
      } else {
        tStraight = fst*Lmtrs/(D.vSt/3.6);
      }
      const lapSec = tSlow + tMed + tHigh + tStraight;

      // Flow heuristics: direction flips and segment rhythm
      const pts = smoothCache.pts;
      function segTurnSign(s){ let sum=0; for(let i=s.start;i<Math.min(s.end, pts.length-1);i++){ const a=pts[i], b=pts[i+1]; const dx=b.x-a.x, dy=b.y-a.y; const dl=Math.hypot(dx,dy)||1; sum += (curvaturePerUnit(i)||0)*dl; } return Math.sign(sum||0); }
      let flips=0, prevSign=0; const cornerLens=[];
      for(const s of segs){ if(s.type!=='corner') continue; const sign=segTurnSign(s); cornerLens.push(s.len/total); if(prevSign!==0 && sign!==0 && sign!==prevSign) flips++; if(sign!==0) prevSign=sign; }
      const medianCornerSpan = cornerLens.sort((a,b)=>a-b)[Math.floor(cornerLens.length/2)] || 0;
      const flipRatio = corners>0? flips/corners : 0;
      let flow='Good';
      if(flipRatio>0.45 || medianCornerSpan<0.02 || fs>0.35) flow='Messy';
      else if(flipRatio>0.30 || medianCornerSpan<0.03 || fs>0.25) flow='Average';

      // Length guidance per discipline
      let lenNote = 'OK';
      if(lapKm < D.len.short) lenNote = `Short for ${D.label}`;
      else if(lapKm > D.len.long) lenNote = `Long for ${D.label}`;

      const lines = [];
      const unitLabel = D.kind==='stage' ? 'Stage' : 'Lap';
      lines.push(`${unitLabel} estimate: ${formatLapTime(lapSec)} (length ${lapKm.toFixed(1)} km, ${D.label})`);
      lines.push(`Length check: ${lenNote}${D.kind==='stage' ? ' (rally stages vary widely)' : ''}`);
      lines.push(`Flow: ${flow} (zig‚Äëzag ratio ${(flipRatio*100).toFixed(0)}%, median corner span ${(medianCornerSpan*100).toFixed(1)}%)`);
      lines.push(`Corner mix: ${corners} corners ‚Äî slow ${(fs*100).toFixed(0)}%, medium ${(fm*100).toFixed(0)}%, high ${(fh*100).toFixed(0)}%`);
      if(D.label==='F1'){
        lines.push(`Straights: ${(fst*100).toFixed(0)}% of lap ‚Ä¢ DRS ${(fdrs*100).toFixed(0)}% ‚Ä¢ longest ${(longestStraightPct).toFixed(0)}%`);
      } else {
        lines.push(`Straights: ${(fst*100).toFixed(0)}% of ${D.kind} ‚Ä¢ longest ${(longestStraightPct).toFixed(0)}%`);
      }

      // Nudges
      if(flow==='Messy' && longestStraightPct<8) lines.push('Tip: add a longer straight or reduce rapid direction changes.');
      if(fs>0.35) lines.push('Tip: too many slow corners; open radii or insert breathers.');
      if(D.label==='F1' && fdrs<0.05 && fst>0.20) lines.push('Tip: consider one DRS‚Äëcapable straight.');
      if(lapSec<60 && D.kind==='lap') lines.push('Note: lap time is quite short (kart‚Äëlike).');
      if(lapSec>120 && D.kind==='lap') lines.push('Note: lap time is long; check length or corner density.');
      if(D.kind==='stage' && lapSec>1800) lines.push('Note: very long stage; consider splitting into sections.');

      UI.suggestBox.textContent = lines.join('\n');
    }

    function drawSegment(center, start, end, color, width=3, dash=null){
      const n = center.length; if(n===0) return;
      ctx.save(); ctx.strokeStyle = color; ctx.lineWidth = width; if(dash) ctx.setLineDash(dash);
      const drawRange = (a,b)=>{
        if(b < a) return; let p = worldToScreen(center[a]); ctx.beginPath(); ctx.moveTo(p.x,p.y);
        for(let i=a+1;i<=b && i<n;i++){ p=worldToScreen(center[i]); ctx.lineTo(p.x,p.y); }
        ctx.stroke();
      };
      if(end >= start){
        drawRange(start, end);
      } else if(UI.closed.checked) {
        // Wrap-around segment across the loop seam
        drawRange(start, n-1);
        drawRange(0, end);
      }
      ctx.setLineDash([]); ctx.restore();
    }
    function drawLabelAt(center, start, end, text, bg, fg){
      const n = center.length; if(n===0) return;
      let mid;
      if(UI.closed.checked && end < start){
        const span = (n - start) + end; // approximate span length in samples
        mid = (start + Math.floor(span/2)) % n;
      } else {
        mid = Math.floor((start + end) / 2);
      }
      if(mid<0 || mid>=n) return; const p=worldToScreen(center[mid]);
      ctx.save(); ctx.font = '700 11px ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
      const padX=6, padY=3; const tw = ctx.measureText(text).width; const w=tw+padX*2, h=16;
      ctx.fillStyle = bg; ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineWidth=1;
      ctx.beginPath(); const r=6; const x=p.x-w/2, y=p.y-h/2; ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); ctx.fill(); ctx.stroke();
      ctx.fillStyle = fg; ctx.fillText(text, p.x, p.y+0.5); ctx.restore();
    }

    function drawTrackFill(center){ if(center.length<2) return; const polys=buildOffsetPolygons(center); if(!polys) return; // filled road
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--track') || '#2a3347';
      ctx.beginPath(); let p=worldToScreen(polys.left[0]); ctx.moveTo(p.x,p.y); for(let i=1;i<polys.left.length;i++){ p=worldToScreen(polys.left[i]); ctx.lineTo(p.x,p.y) } for(let i=polys.right.length-1;i>=0;i--){ p=worldToScreen(polys.right[i]); ctx.lineTo(p.x,p.y) } ctx.closePath(); ctx.fill();
      // edges
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--edge') || '#ffffff'; ctx.lineWidth = 2; ctx.beginPath(); p=worldToScreen(polys.left[0]); ctx.moveTo(p.x,p.y); for(let i=1;i<polys.left.length;i++){ p=worldToScreen(polys.left[i]); ctx.lineTo(p.x,p.y) } ctx.stroke(); ctx.beginPath(); p=worldToScreen(polys.right[0]); ctx.moveTo(p.x,p.y); for(let i=1;i<polys.right.length;i++){ p=worldToScreen(polys.right[i]); ctx.lineTo(p.x,p.y) } ctx.stroke();

      // Banking visualization: rib lines across the road at intervals
      if(UI.showBankViz.checked && smoothCache.pts.length>2){ const step=Math.max(6, Math.floor(parseInt(UI.resolution.value,10)/20)); for(let i=0;i<smoothCache.pts.length; i+=step){ const l=worldToScreen(polys.left[i]); const r=worldToScreen(polys.right[i]); const bk=bankAtSample(i); ctx.strokeStyle=colorForBank(bk); ctx.lineWidth=1.5; ctx.setLineDash([8,6]); ctx.beginPath(); ctx.moveTo(l.x,l.y); ctx.lineTo(r.x,r.y); ctx.stroke(); ctx.setLineDash([]); } }
    }

    // Pitlane drawing with constant width
    function buildOffsetPolygonsConstWidth(center, width){ if(center.length<2) return null; const left=[], right=[]; const n=center.length; for(let i=0;i<n;i++){ const p=center[i]; const pm=center[Math.max(0,i-1)]; const pp=center[Math.min(n-1,i+1)]; const tx=pp.x-pm.x, ty=pp.y-pm.y; const len=Math.hypot(tx,ty)||1; const nx=-ty/len, ny=tx/len; const hw=width*0.5; left.push({x:p.x+nx*hw, y:p.y+ny*hw}); right.push({x:p.x-nx*hw, y:p.y-ny*hw}); } return {left,right}; }
    function drawPitlane(){ if(!UI.pitEnabled || !UI.pitEnabled.checked) return; if(pitVNodes.length<2) return; const res=Math.max(60, Math.floor(parseInt(UI.resolution.value,10)/2));
      // Sample pit vector centerline with arcs
      const n=pitVNodes.length; const infos=new Array(n); for(let i=0;i<n;i++) infos[i]=computeCornerInfoFor(pitVNodes, pitVectorClosed, i);
      const center=[]; const start=infos[0]; const startP=(start&&start.valid)? start.T1 : {x:pitVNodes[0].x, y:pitVNodes[0].y}; center.push(startP);
      const segRes=Math.max(2, Math.floor(res/50));
      for(let i=0;i<n;i++){
        const inf=infos[i];
        if(inf && inf.valid){ let a1=inf.a1, a2=inf.a2; if(inf.ccw){ while(a2>a1) a2-=Math.PI*2; } else { while(a2<a1) a2+=Math.PI*2; }
          const delta=a2-a1; const steps=Math.max(2, Math.min(64, Math.floor(Math.abs(delta)/(Math.PI/segRes))+1));
          for(let k=1;k<=steps;k++){ const ang=a1 + delta*(k/steps); center.push({x:inf.center.x + Math.cos(ang)*inf.r, y:inf.center.y + Math.sin(ang)*inf.r}); }
        } else { center.push({x:pitVNodes[i].x, y:pitVNodes[i].y}); }
        const next=infos[(i+1)%n]; const hasNext=pitVectorClosed? true : (i+1<n); if(!hasNext) break; const nextP=(next&&next.valid)? next.T1 : {x:pitVNodes[(i+1)%n].x, y:pitVNodes[(i+1)%n].y}; center.push(nextP);
      }
      const polys=buildOffsetPolygonsConstWidth(center, parseFloat(UI.pitWidth.value)||8); if(!polys) return;
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--pit') || '#24304a'; ctx.beginPath(); let p=worldToScreen(polys.left[0]); ctx.moveTo(p.x,p.y); for(let i=1;i<polys.left.length;i++){ p=worldToScreen(polys.left[i]); ctx.lineTo(p.x,p.y) } for(let i=polys.right.length-1;i>=0;i--){ p=worldToScreen(polys.right[i]); ctx.lineTo(p.x,p.y) } ctx.closePath(); ctx.fill(); const edgeCol = getComputedStyle(document.documentElement).getPropertyValue('--pit-edge') || '#ffd166'; ctx.strokeStyle=edgeCol; ctx.lineWidth=2; ctx.beginPath(); p=worldToScreen(polys.left[0]); ctx.moveTo(p.x,p.y); for(let i=1;i<polys.left.length;i++){ p=worldToScreen(polys.left[i]); ctx.lineTo(p.x,p.y) } ctx.stroke(); ctx.beginPath(); p=worldToScreen(polys.right[0]); ctx.moveTo(p.x,p.y); for(let i=1;i<polys.right.length;i++){ p=worldToScreen(polys.right[i]); ctx.lineTo(p.x,p.y) } ctx.stroke(); }

    function drawAltLayoutsOverlays(){
      if(!UI.showAltOverlays || !UI.showAltOverlays.checked) return;
      const res = Math.max(16, parseInt(UI.resolution.value,10));
      const altCtrlCol = getComputedStyle(document.documentElement).getPropertyValue('--alt-layout-ctrl') || 'rgba(137,166,255,0.35)';
      const altCol = getComputedStyle(document.documentElement).getPropertyValue('--alt-layout') || '#89a6ff';
      for(let i=0;i<layouts.length;i++){
        if(i===activeLayoutIndex) continue;
        const ptsArr = layouts[i].points || [];
        if(ptsArr.length<2) continue;
        if(mode!=='vector'){
          const sm = sampleSplineWithMap(ptsArr, UI.closed.checked, Math.floor(res*0.7)).pts;
          // control polyline
          if(UI.showCtrl.checked && ptsArr.length>1){
            ctx.strokeStyle=altCtrlCol; ctx.lineWidth=1; ctx.setLineDash([4,4]);
            ctx.beginPath(); let p=worldToScreen(ptsArr[0]); ctx.moveTo(p.x,p.y);
            for(let j=1;j<ptsArr.length;j++){ p=worldToScreen(ptsArr[j]); ctx.lineTo(p.x,p.y) }
            if(UI.closed.checked){ const p0=worldToScreen(ptsArr[0]); ctx.lineTo(p0.x,p0.y) }
            ctx.stroke(); ctx.setLineDash([]);
          }
          // smoothed centerline
          ctx.save();
          ctx.strokeStyle=altCol; ctx.globalAlpha=0.65; ctx.lineWidth=1.5;
          ctx.beginPath(); let q=worldToScreen(sm[0]); ctx.moveTo(q.x,q.y);
          for(let k=1;k<sm.length;k++){ q=worldToScreen(sm[k]); ctx.lineTo(q.x,q.y); }
          ctx.stroke();
          ctx.restore();
        }
      }
      // In vector mode, also show other layouts' vector outlines
      if(mode==='vector'){
        for(let i=0;i<layouts.length;i++){
          if(i===activeLayoutIndex) continue;
          const v = layouts[i].vector;
          if(v && v.nodes && v.nodes.length>=2){
            strokeVectorOutline(v.nodes, !!v.closed, altCol, 2, [6,4], 0.65);
          } else {
            // Fallback: draw smoothed centerline if no vector present for that layout
            const ptsArr = layouts[i].points || [];
            if(ptsArr.length<2) continue;
            const sm = sampleSplineWithMap(ptsArr, UI.closed.checked, Math.floor(res*0.7)).pts;
            ctx.save(); ctx.strokeStyle=altCol; ctx.globalAlpha=0.5; ctx.lineWidth=1.5;
            ctx.beginPath(); let q=worldToScreen(sm[0]); ctx.moveTo(q.x,q.y);
            for(let k=1;k<sm.length;k++){ q=worldToScreen(sm[k]); ctx.lineTo(q.x,q.y); }
            ctx.stroke(); ctx.restore();
          }
        }
      }
    }

    function draw(){ const rect=canvas.getBoundingClientRect(); ctx.clearRect(0,0,rect.width,rect.height); const smoothed = smoothCache.pts.length? smoothCache.pts : sampleSplineWithMap(points, UI.closed.checked, parseInt(UI.resolution.value,10)).pts; // Track surface first
      if(smoothed.length>1){ drawTrackFill(smoothed); }
      // Pitlane
      drawPitlane();
      // Alternate layouts overlays (centerlines and control polylines)
      if(!previewMode){ drawAltLayoutsOverlays(); }

      // Analysis overlays
      if(analysisMode && smoothed.length>2){
        const res = analysisCache || computeAnalysis(); analysisCache = res; const segs = res.segments;
        for(const s of segs){
          if(s.type==='corner'){
            const root = getComputedStyle(document.documentElement);
            const color = s.subtype==='slow'? (root.getPropertyValue('--corner-slow')||'#ff5a5a') : s.subtype==='medium'? (root.getPropertyValue('--corner-med')||'#ffb84d') : (root.getPropertyValue('--corner-fast')||'#74d680');
            drawSegment(smoothed, s.start, s.end, color, 3);
            if(!previewMode){ const label = s.subtype==='slow' ? 'Slow' : (s.subtype==='medium' ? 'Medium' : 'High'); drawLabelAt(smoothed, s.start, s.end, label, 'rgba(14,28,50,0.85)', '#d2e6ff'); }
          } else if(s.subtype==='drs'){
            const drsColor = (getComputedStyle(document.documentElement).getPropertyValue('--drs')||'#4ec9ff');
            drawSegment(smoothed, s.start, s.end, drsColor, 5, [10,8]);
            if(!previewMode){ drawLabelAt(smoothed, s.start, s.end, 'DRS?', 'rgba(6,34,46,0.85)', '#bfefff'); }
          }
        }
      }
      if(!previewMode){ // grid
        if(UI.snap.checked){ const g=parseFloat(UI.grid.value)||24; ctx.fillStyle='rgba(16,35,61,0.9)'; const tl=screenToWorld(0,0), br=screenToWorld(rect.width,rect.height); const startX=Math.floor(tl.x/g)*g, startY=Math.floor(tl.y/g)*g; for(let x=startX;x<br.x;x+=g){ const a=worldToScreen({x,y:tl.y}), b=worldToScreen({x,y:br.y}); ctx.fillRect(Math.round(a.x)+0.5,a.y,1,b.y-a.y) } for(let y=startY;y<br.y;y+=g){ const a=worldToScreen({x:tl.x,y}), b=worldToScreen({x:br.x,y}); ctx.fillRect(a.x,Math.round(a.y)+0.5,b.x-a.x,1) } }
        if(mode!=='vector'){
          // control polyline
          if(UI.showCtrl.checked && points.length>1){ ctx.strokeStyle='rgba(78,161,255,0.5)'; ctx.lineWidth=1.5; ctx.setLineDash([5,5]); ctx.beginPath(); let p=worldToScreen(points[0]); ctx.moveTo(p.x,p.y); for(let i=1;i<points.length;i++){ p=worldToScreen(points[i]); ctx.lineTo(p.x,p.y) } if(UI.closed.checked){ const p0=worldToScreen(points[0]); ctx.lineTo(p0.x,p0.y) } ctx.stroke(); ctx.setLineDash([]); }
          // centerline for reference
          if(smoothed.length>1){ ctx.strokeStyle='#cfd8ea'; ctx.lineWidth=1; ctx.beginPath(); let p=worldToScreen(smoothed[0]); ctx.moveTo(p.x,p.y); for(let i=1;i<smoothed.length;i++){ p=worldToScreen(smoothed[i]); ctx.lineTo(p.x,p.y) } ctx.stroke(); }
          // points
          for(let i=0;i<points.length;i++){
            const p=worldToScreen(points[i]);
            ctx.beginPath();
            ctx.arc(p.x,p.y, i===selected?7:5, 0, Math.PI*2);
            ctx.fillStyle = i===selected? '#ffd166' : '#ffffff';
            ctx.strokeStyle='rgba(0,0,0,0.5)';
            ctx.lineWidth=2;
            ctx.fill();
            ctx.stroke();
            const r=9;
            ctx.beginPath();
            ctx.arc(p.x,p.y,r,0,Math.PI*2);
            const tMin = parseFloat(UI.ptension.min)||-2;
            const tMax = parseFloat(UI.ptension.max)||1;
            const tVal = (points[i].t ?? 0);
            const vis = (Math.max(tMin, Math.min(tMax, tVal)) - tMin) / ((tMax - tMin) || 1);
            ctx.strokeStyle=`rgba(113,249,168,${0.15 + 0.65*vis})`;
            ctx.lineWidth=2;
            ctx.stroke();
            // Corner marker
            if(points[i].c){
              ctx.fillStyle='#ffb84d';
              ctx.strokeStyle='rgba(0,0,0,0.5)';
              ctx.beginPath();
              ctx.moveTo(p.x+12, p.y);
              ctx.lineTo(p.x+18, p.y-6);
              ctx.lineTo(p.x+18, p.y+6);
              ctx.closePath();
              ctx.fill();
              ctx.stroke();
            }
          }
        }
        // pit points when editing
        if(pitEditMode){
          for(let i=0;i<pitVNodes.length;i++){
            const q=worldToScreen(pitVNodes[i]);
            ctx.beginPath(); ctx.arc(q.x,q.y, i===pitVSelected?7:5, 0, Math.PI*2);
            ctx.fillStyle = i===pitVSelected ? '#ffd166' : '#ffffff';
            ctx.strokeStyle='rgba(0,0,0,0.45)'; ctx.lineWidth=2; ctx.fill(); ctx.stroke();
          }
        }
        if(mode!=='vector'){
          const len=curveLength(smoothed);
          const tSel=selected>=0 && points[selected]? (points[selected].t||0).toFixed(2):'‚Äî';
          const tbSel=selected>=0 && points[selected]? (points[selected].tb||0).toFixed(2):'‚Äî';
          const wSel=selected>=0 && points[selected]? (points[selected].w||getDefaultWidth()).toFixed(1):'‚Äî';
          const bSel=selected>=0 && points[selected]? (points[selected].b||0).toFixed(1)+'¬∞':'‚Äî';
          const lay = layouts[activeLayoutIndex] || {name:'Main'};
          hud.textContent = `layout ${activeLayoutIndex+1}/${layouts.length} ${lay.name} | mode ${mode} | pts ${points.length} | curve ${smoothed.length} | length ${len.toFixed(1)} | sel ${selected>=0?selected:'‚Äî'} t=${tSel} tb=${tbSel} w=${wSel} b=${bSel} | res ${UI.resolution.value}${analysisMode?' | analysis ON':''}`;
        }
      } else if(previewEditMode){
        // Show only smaller dots for editing in preview
        for(let i=0;i<points.length;i++){
          const p=worldToScreen(points[i]);
          ctx.beginPath();
          ctx.arc(p.x,p.y, i===selected?6:4, 0, Math.PI*2);
          ctx.fillStyle = i===selected? '#ffd166' : '#ffffff';
          ctx.strokeStyle='rgba(0,0,0,0.45)';
          ctx.lineWidth=1.5;
          ctx.fill();
          ctx.stroke();
        }
      }

      // Optional Start/Finish visibility in Preview mode
      if(previewMode && UI.sfPreview && UI.sfPreview.checked){
        // Start/Finish marker overlay (node-based)
        if(startFinishVNode>=0 && startFinishVNode<n){
          const i = startFinishVNode; const j = (i+1 < n) ? i+1 : (vectorClosed ? 0 : i);
          const A=vNodes[i], B=vNodes[j]; let tx=B.x-A.x, ty=B.y-A.y; const L=Math.hypot(tx,ty)||1; tx/=L; ty/=L; const nx=-ty, ny=tx; const half=(parseFloat(UI.globalWidth?.value)||12)*0.5;
          const Lp={x:A.x+nx*half, y:A.y+ny*half}, Rp={x:A.x-nx*half, y:A.y-ny*half}; const ls=worldToScreen(Lp), rs=worldToScreen(Rp);
          ctx.save(); ctx.strokeStyle='#ffffff'; ctx.lineWidth=3; ctx.setLineDash([6,4]); ctx.beginPath(); ctx.moveTo(ls.x,ls.y); ctx.lineTo(rs.x,rs.y); ctx.stroke(); ctx.setLineDash([]); ctx.restore();
        }
        // Start/Finish marker overlay (track-click-based)
        if(!isNaN(startFinishVNode) && startFinishVNode<0 && startFinishTrack){
          const tx = startFinishTrack.tx || 1, ty = startFinishTrack.ty || 0; const nx=-ty, ny=tx; const half=(parseFloat(UI.globalWidth?.value)||12)*0.5; const A={x:startFinishTrack.x,y:startFinishTrack.y};
          const Lp={x:A.x+nx*half, y:A.y+ny*half}, Rp={x:A.x-nx*half, y:A.y-ny*half}; const ls=worldToScreen(Lp), rs=worldToScreen(Rp);
          ctx.save(); ctx.strokeStyle='#ffffff'; ctx.lineWidth=3; ctx.setLineDash([6,4]); ctx.beginPath(); ctx.moveTo(ls.x,ls.y); ctx.lineTo(rs.x,rs.y); ctx.stroke(); ctx.setLineDash([]); ctx.restore();
        }
      }

      // Vector overlay / HUD when in vector mode
      if(mode==='vector'){
        drawVector();
        if(!previewMode){
          const N=vNodes.length; const rSel=(vSelected>=0 && vNodes[vSelected])? (vNodes[vSelected].r||0).toFixed(1) : '‚Äî'; const tSel=(vSelected>=0 && vNodes[vSelected])? vNodes[vSelected].type : '‚Äî';
          hud.textContent = `mode vector | nodes ${N} | closed ${vectorClosed} | sel ${vSelected>=0?vSelected:'‚Äî'} r=${rSel} type=${tSel} | inflate ${UI.vectorInflate?UI.vectorInflate.value:0}`;
        }
      }
    }

    // ===== Test shapes =====
    function loadHairpinTest(){ const arr=[ {x:-200,y:-80,t:0.2,w:12,b:4}, {x: -40,y:-120,t:0.4,w:12,b:6}, {x:  40,y:-110,t:0.7,w:10,b:10}, {x: 120,y: -30,t:0.8,w:8,b:6}, {x:  20,y:  40,t:0.6,w:10,b:2}, {x:-140,y:  10,t:0.3,w:12,b:0} ]; layouts[activeLayoutIndex].points.length=0; Array.prototype.push.apply(layouts[activeLayoutIndex].points, arr); points = layouts[activeLayoutIndex].points; UI.closed.checked=true; selected=2; syncSelectedUI(); recompute(); fitToScreen(); draw(); }
    function loadChicaneTest(){ const arr=[ {x:-220,y: -40,t:0.3,w:12,b:0}, {x:-120,y: -60,t:0.7,w:12,b:-4}, {x: -40,y: -20,t:0.7,w:10,b:-8}, {x:  60,y: -60,t:0.7,w:10,b:6}, {x: 160,y: -10,t:0.4,w:12,b:8}, {x:  60,y:  60,t:0.6,w:14,b:3}, {x:-100,y:  40,t:0.4,w:12,b:0} ]; layouts[activeLayoutIndex].points.length=0; Array.prototype.push.apply(layouts[activeLayoutIndex].points, arr); points = layouts[activeLayoutIndex].points; UI.closed.checked=false; selected=3; syncSelectedUI(); recompute(); fitToScreen(); draw(); }

    // Boot - Initialize with first state in history
    doResize(); setMode('vector'); refreshLayoutUI(); updateSelectedControlsVisibility(); syncBadges(); syncSelectedUI(); syncSelectedVectorUI(); recompute(); fitToScreen();
    // Save initial empty state to history
    history.push(captureState());
    historyIndex = 0;
    updateUndoRedoButtons();
  </script>
</body>
</html>
